(self.webpackChunkrahul_gill_github_io=self.webpackChunkrahul_gill_github_io||[]).push([[8991],{3173:function(e,t,n){"use strict";n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return N},frontMatter:function(){return m},metadata:function(){return p},toc:function(){return h}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=n(3456),i=["components"],m={title:"Trees"},l=void 0,p={unversionedId:"dsa/Trees",id:"dsa/Trees",title:"Trees",description:"Data Structure",source:"@site/docs/dsa/8. Trees.md",sourceDirName:"dsa",slug:"/dsa/Trees",permalink:"/docs/dsa/Trees",tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Trees"},sidebar:"docs",previous:{title:"Linked Lists",permalink:"/docs/dsa/LinkedList"},next:{title:"Graph Traversal and MST",permalink:"/docs/dsa/GraphTraversalAndMst"}},d={},h=[{value:"Data Structure",id:"data-structure",level:2},{value:"Tree traversals",id:"tree-traversals",level:2},{value:"Binary Search Trees",id:"binary-search-trees",level:2},{value:"BST Operations",id:"bst-operations",level:3},{value:"Questions",id:"questions",level:2},{value:"Check if two binary trees are same",id:"check-if-two-binary-trees-are-same",level:3},{value:"Check if BT is balanced",id:"check-if-bt-is-balanced",level:3},{value:"Maximum depth/height or tree",id:"maximum-depthheight-or-tree",level:3},{value:"Diameter of binary tree",id:"diameter-of-binary-tree",level:3},{value:"Maximum path sum",id:"maximum-path-sum",level:3},{value:"Zig-zag traversal",id:"zig-zag-traversal",level:3},{value:"Leaf nodes of the tree",id:"leaf-nodes-of-the-tree",level:3},{value:"Boundary traversal",id:"boundary-traversal",level:3},{value:"Vertical order traversal",id:"vertical-order-traversal",level:3},{value:"Top view of a tree",id:"top-view-of-a-tree",level:3},{value:"Bottom view of a tree",id:"bottom-view-of-a-tree",level:3},{value:"Right/Left view of a tree",id:"rightleft-view-of-a-tree",level:3},{value:"Check if tree is symmetrical",id:"check-if-tree-is-symmetrical",level:3},{value:"Path from root to a node of tree",id:"path-from-root-to-a-node-of-tree",level:3},{value:"Lowest common ancestor",id:"lowest-common-ancestor",level:3},{value:"Maximum width of tree",id:"maximum-width-of-tree",level:3},{value:"Children sum problem",id:"children-sum-problem",level:3},{value:"Nodes at a distance k",id:"nodes-at-a-distance-k",level:3},{value:"Minimum time to burn tree from a node",id:"minimum-time-to-burn-tree-from-a-node",level:3},{value:"Count nodes in complete binary tree in less than mathcal{O}(n)",id:"count-nodes-in-complete-binary-tree-in-less-than-mathcalon",level:3},{value:"Construct Binary tree from inorder &amp; preorder traversal",id:"construct-binary-tree-from-inorder--preorder-traversal",level:3},{value:"Comstruct Binary tree from inorder &amp; postorder traversal",id:"comstruct-binary-tree-from-inorder--postorder-traversal",level:3},{value:"Serializing and Deserializing a binary tree",id:"serializing-and-deserializing-a-binary-tree",level:3},{value:"Morris Traversal",id:"morris-traversal",level:3},{value:"Flatten binary tree to linked list in-place",id:"flatten-binary-tree-to-linked-list-in-place",level:3},{value:"Check if BT is a BST",id:"check-if-bt-is-a-bst",level:3}],c={toc:h};function N(e){var t=e.components,m=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},c,m,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"data-structure"},"Data Structure"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"tree is graph which is acyclic(no cycles) and connected"),(0,o.kt)("li",{parentName:"ul"},"terms: root, childern, parent, ancestors, leaf node, subtree")),(0,o.kt)(s.Mermaid,{config:{mermaid:{theme:"dark"}},chart:"flowchart TD;\n\t1 --\x3e 2 --\x3e 4 --\x3e 8 --\x3e 9\n\t1 --\x3e 3 --\x3e 5 --\x3e 6\n\t5 --\x3e 7 --\x3e 10",mdxType:"Mermaid"}),(0,o.kt)("p",null,"here 1 is root.\n2 and 3 are its children.\nits parent of 2 and 3.\n10,3 and 9 are leaf nodes.\n5, 3 and 1 are ancestors of 6.\n3,5,6,7,10 forms the subtree of node 3. "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"terms2: binary tree",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"full BT: every node has 0/2 children "),(0,o.kt)("li",{parentName:"ul"},"complete BT: all levels filled except bottom level, bottom level has nodes on left side"),(0,o.kt)("li",{parentName:"ul"},"perfect BT: all leaf nodes at same level"),(0,o.kt)("li",{parentName:"ul"},"balance BT: ",(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mi",{parentName:"mrow"},"e"),(0,o.kt)("mi",{parentName:"mrow"},"i"),(0,o.kt)("mi",{parentName:"mrow"},"g"),(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mi",{parentName:"mrow"},"t"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"l"),(0,o.kt)("mi",{parentName:"mrow"},"e"),(0,o.kt)("mi",{parentName:"mrow"},"f"),(0,o.kt)("mi",{parentName:"mrow"},"t"),(0,o.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"_"),(0,o.kt)("mi",{parentName:"mrow"},"n"),(0,o.kt)("mi",{parentName:"mrow"},"o"),(0,o.kt)("mi",{parentName:"mrow"},"d"),(0,o.kt)("mi",{parentName:"mrow"},"e"),(0,o.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,o.kt)("mi",{parentName:"mrow"},"r"),(0,o.kt)("mi",{parentName:"mrow"},"i"),(0,o.kt)("mi",{parentName:"mrow"},"g"),(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mi",{parentName:"mrow"},"t"),(0,o.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"_"),(0,o.kt)("mi",{parentName:"mrow"},"n"),(0,o.kt)("mi",{parentName:"mrow"},"o"),(0,o.kt)("mi",{parentName:"mrow"},"d"),(0,o.kt)("mi",{parentName:"mrow"},"e"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,o.kt)("mo",{parentName:"mrow"},"\u2264"),(0,o.kt)("mn",{parentName:"mrow"},"1")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"height(left\\_node, right\\_node) \\leq 1")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1.06em",verticalAlign:"-0.31em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,o.kt)("span",{parentName:"span",className:"mord",style:{marginRight:"0.02778em"}},"_"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,o.kt)("span",{parentName:"span",className:"mpunct"},","),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,o.kt)("span",{parentName:"span",className:"mord",style:{marginRight:"0.02778em"}},"_"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")"),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,o.kt)("span",{parentName:"span",className:"mrel"},"\u2264"),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},"1")))))),(0,o.kt)("li",{parentName:"ul"},"degenerate BT: like a linked list, linear, every node has single children"))),(0,o.kt)("li",{parentName:"ul"},"binary search tree: all nodes on the left subtree less than the node and all nodes on the right subtree are greater than the node."),(0,o.kt)("li",{parentName:"ul"},"Representation of tree")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"using data_t = int;\nstruct node_t{\n    data_t data;\n    node_t* left;\n    node_t* right;\n};\n\n//or\ntemplate<typename T>\nstruct Node {\n    T data;\n    Node* left;\n    Node* right;\n    Node* parent;\n    Node():left(NULL), right(NULL), parent(NULL), data(T()) {}\n    Node(T data_): left(NULL), right(NULL), parent(NULL), data(data_) {}\n};\n")),(0,o.kt)("h2",{id:"tree-traversals"},"Tree traversals"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"all traversals are ",(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"N"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(N)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))," in time and space."),(0,o.kt)("li",{parentName:"ul"},"breadth first search or level order traversal")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void bfs(node_t* root, function<void(data_t)>& f){\n    if(root == NULL)\n        return;\n    \n    queue<node_t*> q;\n    q.push(root);\n    while(!q.empty()){\n        node_t node = q.front();\n        f(node->data);\n        if(node->left != NULL) q.push(node->left);\n        if(node->right != NULL) q.push(node->right);\n        q.pop();\n    }\n}\n//bfs with level info\nvector<vector<data_t>> bfs(node_t* root){\n    vector<vector<data_t>> ans;\n    if(root == NULL)\n        return ans;\n    \n    queue<node_t*> q;\n    q.push(root);\n    while(!q.empty()){\n        int q_size = q.size();\n        vector<data_t> level;\n        for(int i=0; i<q_size; ++i){\n            node_t* node = q.front();\n            if(node->left != NULL) q.push(node->left);\n            if(node->right != NULL) q.push(node->right);\n            q.pop();\n            level.push_back(node->data);\n        }\n        ans.push_back(level);\n    }\n    return ans;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"depth first search")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//recusrive are O(height) but in worst case height = N so O(N)\nvoid preOrder(node_t* root, const function<void(data_t)>& f){\n    if(root == NULL)\n        return;\n    f(root->data);\n    preOrder(root->left, f);\n    preOrder(root->right, f);\n}\n\nvoid postOrder(node_t* root, const function<void(data_t)>& f){\n    if(root == NULL)\n        return;\n    postOrder(root->left, f);\n    postOrder(root->right, f);\n    f(root->data);\n}\n\nvoid inOrder(node_t* root, const function<void(data_t)>& f){\n    if(root == NULL)\n        return;\n    inOrder(root->left, f);\n    f(root->data);\n    inOrder(root->right, f);\n}\n\n//iterative versions\nvoid preOrder(node_t* root, const function<void(data_t)>& f){\n    if(root == NULL)\n        return;\n    stack<node_t*> stk;\n    stk.push(root);\n    while(!stk.empty()){\n        auto node = stk.top();\n        stk.pop();\n        f(node->data);\n        if(node->right != NULL) stk.push(node->right);\n        if(node->left != NULL) stk.push(node->left);\n    }\n}\n\ntemplate<typename Functor>\nvoid inOrder(node_t* root, Fuctor&& f){\n    stack<node_t*> stk;\n    node_t* node = root;\n    while(1){\n        if(root != NULL){\n            stk.push(root);\n            node = node->left;\n        }\n        else if(!stk.empty()){\n            node = stk.top(); stk.pop();\n            f(node->data);\n            node = node->right;\n        }\n        else\n            return;\n    }\n}\n\n\nvoid postOrder(node_t* root, const function<void(data_t)>& f){\n    stack<node_t*> stk;\n    while(1){\n        if(root != NULL){\n            stk.push(root);\n            root = root->left;\n        }\n        else if(!stk.empty()){\n            node_t* tmp = stk.top();\n            if(tmp->right != NULL)\n                root = tmp->right;\n            else{\n                stk.pop();\n                f(tmp->data);\n                while(!stk.empty() && stk.top()->right== tmp){\n                    tmp = stk.top();\n                    stk.pop();\n                    f(tmp->data);\n                }\n            }\n        }\n        else \n            return;\n    }\n}\n\n//inorder, preorder, postorder all at onces\nusing list_t = vector<int>\ntuple<list_t, list_t, list_t> prePostIn(node_t* root){\n    stack<pair<node_t*, int>> stk;\n    stk.push({root, 1});\n    vector<int> pre, in, post;\n    while(!stk.empty()){\n        auto it = stk.top();\n        stk.pop();\n        if(it.second == 1){\n            pre.push_back(it.first);\n            it.second++;\n            stk.push(it);\n            if(it.first->left != NULL)\n                stk.push({it.first->left, 1});\n        }\n        else if(it.second == 2){\n            in.push_back(it.first);\n            it.second++;\n            stk.push(it);\n            if(it.first->right != NULL)\n                stk.push({it.first->right, 1});\n        }\n        else\n            post.push_back(it.first);\n    }\n    return make_tuple(pre,in,post);\n}\n")),(0,o.kt)("h2",{id:"binary-search-trees"},"Binary Search Trees"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"operations: search, min, max, successor, predecessor, insert, delete all in ",(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mi",{parentName:"mrow"},"e"),(0,o.kt)("mi",{parentName:"mrow"},"i"),(0,o.kt)("mi",{parentName:"mrow"},"g"),(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mi",{parentName:"mrow"},"t"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(height)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,o.kt)("li",{parentName:"ul"},"need extra 2n space for left and right child pointers"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"BST property"),":\tfor a node x, ",(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"x"),(0,o.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,o.kt)("mi",{parentName:"mrow"},"l"),(0,o.kt)("mi",{parentName:"mrow"},"e"),(0,o.kt)("mi",{parentName:"mrow"},"f"),(0,o.kt)("mi",{parentName:"mrow"},"t"),(0,o.kt)("mo",{parentName:"mrow"},"<"),(0,o.kt)("mi",{parentName:"mrow"},"x"),(0,o.kt)("mo",{parentName:"mrow"},"<"),(0,o.kt)("mi",{parentName:"mrow"},"x"),(0,o.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,o.kt)("mi",{parentName:"mrow"},"r"),(0,o.kt)("mi",{parentName:"mrow"},"i"),(0,o.kt)("mi",{parentName:"mrow"},"g"),(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mi",{parentName:"mrow"},"t")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x.left <x < x.right")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8888799999999999em",verticalAlign:"-0.19444em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,o.kt)("span",{parentName:"span",className:"mord"},"."),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,o.kt)("span",{parentName:"span",className:"mrel"},"<"),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5782em",verticalAlign:"-0.0391em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,o.kt)("span",{parentName:"span",className:"mrel"},"<"),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8888799999999999em",verticalAlign:"-0.19444em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,o.kt)("span",{parentName:"span",className:"mord"},"."),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"t")))))),(0,o.kt)("li",{parentName:"ul"},"for duplicates, either track a counter of duplicates or change condition as L <= node < R"),(0,o.kt)("li",{parentName:"ul"},"usually height is kept roughly ",(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"lg"),(0,o.kt)("mo",{parentName:"mrow"},"\u2061"),(0,o.kt)("mi",{parentName:"mrow"},"N")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\lg N")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8888799999999999em",verticalAlign:"-0.19444em"}}),(0,o.kt)("span",{parentName:"span",className:"mop"},"l",(0,o.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," with techniques like AVL trees\t or RB trees")),(0,o.kt)("h3",{id:"bst-operations"},"BST Operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"successor: if right node not-null return it, else lowest right child of left child of the node; similar way predecessor")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"node_t* successor(node_t* node){\n    if(node->right == NULL) \n        return NULL;\n    \n    auto righty = node->righty;\n    while(righty->left != NULL) \n        righty = righty->left;\n    return righty;\n\n}\nnode_t* predecessor(node_t* node){\n    if(node->left == NULL) \n        return NULL;\n    \n    auto lefty = node->left;\n    while(lefty->right != NULL) \n        lefty = lefty->right;\n    return lefty;\n}\n\nnode_t* min(node_t* root){\n    if(root == NULL)\n        return NULL;\n    \n    while(root->left != NULL)\n        root = root->left;\n    \n    return root;\n}\n\nnode_t* max(node_t* root){\n    if(root == NULL)\n        return NULL;\n    \n    while(root->right != NULL)\n        root = root->right;\n    \n    return root;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"insert")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void insert(node_t* root,data_t data){\n    if(root == NULL)\n        root = new node_t(data);\n    else if(root->data > data)\n        insert(root->left, data);\n    else \n        insert(root->right,data);\n}\n//iterative\nnode_t* insert(node_t* root,data_t data){\n    if(root == NULL){\n        root = new node_t(data);\n        return root;\n    }\n    auto node = root;\n    while(1){\n        if(node->data > data){\n            if(node->left)\n                node = node->left;\n            else{\n                node->left = new node_t(data);\n                break;\n            }\n        }\n        else if(node->data < data){\n            bool s = node->data == 4;\n            if(node->right)\n                node = node->right;\n            else{\n                node->right = new node_t(data);\n                break;\n            }\n        }\n        //if we don't want to modify bst if data exist already in it\n        else\n            break;\n    }\n    return root;\n}\n\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"delete: has three cases: leaf, node with one child, node with two child")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"node_t* delete(node_t* root, data_t data){\n    if(root == NULL) \n        return root;\n    else if(data < root->data) \n        root->left = delete_node(root->left, data);\n    else if(data > root->data) \n        root->right = delete_node(root->right, data);\n    else if(root->left == NULL && root->right == NULL){ // Case 1\n        delete root;\n        root = NULL;\n    }\n    else if(root->left == NULL){ // Case 2\n        node* temp = root;\n        root= root->right;\n        delete temp;\n    }\n    else if(root->right == NULL){ // Case 2\n        node* temp = root;\n        root = root->left;\n        delete temp;\n    }\n    else{ // Case 3: \n        //place successor value at node and delete original successor node\n        node* temp = root->right;\n        while(temp->left != NULL) \n            temp = temp->left;\n        root->data = temp->data;\n        root->right = delete_node(root->right, temp->data);\n    }\n    return root;\n}\n")),(0,o.kt)("h2",{id:"questions"},"Questions"),(0,o.kt)("h3",{id:"check-if-two-binary-trees-are-same"},"Check if two binary trees are same"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"bool sameTree(node root1, node root2){\n    if(root1 == NULL || root2 == NULL)\n        return root1 == root2;\n    if(root1->data == root2->data\n        && sameTree(root1->left,root2->left)\n        && sameTree(root1->right, root2->right))\n        return true;\n}\n")),(0,o.kt)("h3",{id:"check-if-bt-is-balanced"},"Check if BT is balanced"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"bool isBalanced(node_t* root){\n    return check(root) != -1;\n}\nint check(node_t* root){\n    if(root == NULL)\n        return 0;\n    \n    int lh = height(root->left), rh = height(root->right);\n    if(lh == -1 || rh == -1 || abs(lh-rh) > 1) return -1;\n    return 1 + max(lh, rh);\n}\n")),(0,o.kt)("h3",{id:"maximum-depthheight-or-tree"},"Maximum depth/height or tree"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"at any node answer is  = 1 + max(height of left node, height of right node)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"int height(node_t* root){\n    if(root == NULL)\n        return 0;\n    \n    return 1 + max(height(root->left), height(root->right));\n}\n")),(0,o.kt)("h3",{id:"diameter-of-binary-tree"},"Diameter of binary tree"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"diameter: longest path between any two nodes")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"int diameter(node_t* root){\n    int maxi = 0;\n    diameter_helper(root, maxi);\n    return maxi;\n}\n\nint diameter_helper(node_t* root, int& maxi){\n    if(root == NULL)\n        return 0;\n    int lh = diameter_helper(root->left, maxi);\n    int rh = diameter_helper(root->right, maxi);\n    maxi = max(maxi, lh+rh);\n    return 1 + max(lh, rh);\n}\n")),(0,o.kt)("h3",{id:"maximum-path-sum"},"Maximum path sum"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"naive way: maximum of (lh+rh) for every node")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"int max_path(node_t* root){\n    int maxi = INT_MIN;\n    max_path_helper(root, maxi);\n    return maxi;\n}\nint max_path_helper(node_t* root, int& maxi){\n    if(root == NULL)\n        return 0;\n    int lSum = max(0, max_path_helper(root->left, maxi));\n    int rSum = max(0, max_path_helper(root->right, maxi));\n    maxi = max(maxi, lSum + rSum);\n    \n    return root->data + max(lSum, rSum);\n}\n")),(0,o.kt)("h3",{id:"zig-zag-traversal"},"Zig-zag traversal"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"level order traversal alternating directions of traversal of levels(left-right and right-left) for example for this the level order traversal is: 1 2 3 6 5 4  ")),(0,o.kt)(s.Mermaid,{chart:"flowchart TD;\n\t1 --\x3e 2 --\x3e 4\n\t1 --\x3e 3 --\x3e 6\n\t2 --\x3e 5",mdxType:"Mermaid"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<data_t>> zig_zag_traverse(node_t* root){\n    vector<vector<data_t>> ans;\n    if(root == NULL)\n        return ans;\n    \n    queue<node_t*> q;\n    q.push(root);\n    \n    bool leftToRight = 0;\n    while(!q.empty()){\n        int q_size = q.size();\n        vector<data_t> level(q_size);\n        for(int i=0; i<q_size; ++i){\n            node_t* node = q.front();\n            if(node->left != NULL) q.push(node->left);\n            if(node->right != NULL) q.push(node->right);\n            q.pop();\n            level[leftToRight ? i : q_size - i - 1] = node->data;\n        }\n        leftToRight = !leftToRight;\n        ans.push_back(level);\n    }\n    return ans;\n}\n")),(0,o.kt)("h3",{id:"leaf-nodes-of-the-tree"},"Leaf nodes of the tree"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"bool isLeaf(node_t* node){\n    return node->left == NULL && node->right == NULL;\n}\nvoid leaves_helper(node_t* root, vector<int>& res){\n    if(isLeaf(root)){\n        res.push_back(root->data);\n        return;\n    }\n    if(root->left != NULL)\n        leaves_helper(root->left, res);\n    if(root->right != NULL)\n        leaves_helper(root->right, res);\n}\nvector<int> leaves(node_t* root){\n    vector<int> res;\n    leaves_helper(root, res);\n    return res;\n}\n")),(0,o.kt)("h3",{id:"boundary-traversal"},"Boundary traversal"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"for this boundary traversal is: 1 2 3 4 5 6 10 11 9 8 7(anti clockwise)")),(0,o.kt)(s.Mermaid,{chart:"flowchart TD;\n\t1 --\x3e 2 --\x3e 3 --\x3e 4 --\x3e 5\n\t4 --\x3e 6\n\t1 --\x3e 7 --\x3e 8 --\x3e 9 --\x3e 10\n\t9 --\x3e 11",mdxType:"Mermaid"}),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"so left boundary, then leaf nodes and then reverse of right boundary")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> leftBoundary(node_t* root){\n    if(root != NULL)\n        root = root->left;\n    vector<int> res;\n    while(root != NULL){\n        if(!isLeaf(root))\n            res.push_back(root);\n        if(root->left != NULL)\n            root = root->left;\n        else\n            root = root->right;\n    }\n    return res;\n}\nvector<int> rightBoundary(node_t* root){\n    if(root != NULL)\n        root = root->right;\n    vector<int> res;\n    while(root != NULL){\n        if(!isLeaf(root))\n            res.push_back(root);\n        if(root->right != NULL)\n            root = root->right;\n        else\n            root = root->left;\n    }\n    return res;\n}\nvector<int> boundary(node_t* root){\n    vector<int> res;\n    if(root == NULL)\n        return res;\n    if(!isLeaf(root)) res.push_back(root);\n    auto lb = leftBoundary(root);\n    auto rb = rightBoundary(root);\n    auto lf = leaves(root);\n    res.insert(res.end(), lb.begin(), lb.end());\n    res.insert(res.end(), lf.begin(), lf.end());\n    res.insert(res.end(), rb.rbegin(), rb.rend());\n    return res;\n}\n")),(0,o.kt)("h3",{id:"vertical-order-traversal"},"Vertical order traversal"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Screenshot_20220526_090503.png",src:n(8901).Z,width:"1040",height:"690"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"we use level order traversal to get the levels and verticals of all nodes\n",(0,o.kt)("img",{alt:"4d7e4e89711e598f0cd1b602d7bbd927.png",src:n(1542).Z,width:"636",height:"587"}))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<int>> vertical_order_traversal(node_t* root){\n    if(root == NULL)\n        return vector<vector<int>>();\n    map<int, map<int, multiset<int>>> res   ;\n    \n    queue<tuple<node_t*, int,int>> q;\n    q.push({root, 0, 0});\n    while(!q.empty()){\n        auto[node, vertical, level] = q.front();\n        q.pop();\n        res[vertical][level].insert(node->data);\n        if(node->left != NULL)\n            q.push({node->left, vertical-1, level+1});\n        if(node->right != NULL)\n            q.push({node->right, vertical+1, level+1});\n    }\n    vector<vector<int>> ans;\n    for(auto lvToNodes: res){\n        vector<int> column;\n        for(auto nodeSet: lvToNodes.second)\n            column.insert(column.end(), \n                          nodeSet.second.begin(), nodeSet.second.end());\n        ans.push_back(column);\n    }\n    return ans;\n}\n\n")),(0,o.kt)("h3",{id:"top-view-of-a-tree"},"Top view of a tree"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> top_view(node_t* root){\n    if(root == NULL)\n        return vector<int>();\n\n    map<int,int> res;\n    queue<pair<node_t*, int>> q;\n    q.push({root, 0});\n    while(!q.empty()){\n        auto[node, vertical] = q.front();\n        q.pop();\n        if(res.find(vertical) == res.end())\n            res[vertical] = node->data;\n        if(node->left != NULL)\n            q.push({node->left, vertical - 1});\n        if(node->right != NULL)\n            q.push({node->right, vertical + 1});\n    }\n    vector<int> ans;\n    for(auto x: res)\n        ans.push_back(x.second);\n    return ans;\n}\n")),(0,o.kt)("h3",{id:"bottom-view-of-a-tree"},"Bottom view of a tree"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"ac42827e85bcc178fa4ecf198cf5d5a8.png",src:n(9245).Z,width:"902",height:"562"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> bottom_view(node_t* root){\n    if(root == NULL)\n        return vector<int>();\n\n    map<int,int> res;\n    queue<pair<node_t*, int>> q;\n    q.push({root, 0});\n    while(!q.empty()){\n        auto[node, vertical] = q.front();\n        q.pop();\n        res[vertical] = node->data;\n        if(node->left != NULL)\n            q.push({node->left, vertical - 1});\n        if(node->right != NULL)\n            q.push({node->right, vertical + 1});\n    }\n    vector<int> ans;\n    for(auto x: res)\n        ans.push_back(x.second);\n    return ans;\n}\n")),(0,o.kt)("h3",{id:"rightleft-view-of-a-tree"},"Right/Left view of a tree"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> right_view(node_t* root){\n    vector<int> ans;\n    right_view_h(root,0,ans);\n    return ans;\n}\nvector<int> left_view(node_t* root){\n    vector<int> ans;\n    left_view_h(root,0,ans);\n    return ans;\n}\n\nvoid right_view_h(node_t* root, int level, vector<int>& ans){\n    if(root == NULL)\n        return;\n    if(level == ans.size())\n        ans.push_back(root->data);\n    right_view(root->right, level+1);\n    right_view(root->left, level+1);\n}\nvoid left_view_h(node_t* root, int level, vector<int>& ans){\n    if(root == NULL)\n        return;\n    if(level == ans.size())\n        ans.push_back(root->data);\n    right_view(root->left, level+1);\n    right_view(root->right, level+1);\n}\n")),(0,o.kt)("h3",{id:"check-if-tree-is-symmetrical"},"Check if tree is symmetrical"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"if tree is symmetrical then Inorder Root-Left-Right traversal of left subtree and Inorder Root-Right-Left traversal of right subtree of root will be same")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"bool is_symmetrical(node_t* root){\n    return root == NULL || sym_check_helper(root->left, root->right);\n}\n\nbool sym_check_helper(node_t* left, node_t* right){\n    if(left == NULL || right == NULL)\n        return left == right;\n    return left->data == right->data\n        && sym_check_helper(left->left, right->right)\n        && sym_check_helper(left->right, right->left);\n        \n}\n")),(0,o.kt)("h3",{id:"path-from-root-to-a-node-of-tree"},"Path from root to a node of tree"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"bool path_from_root_helper(node_t* root, \n                                  int node_value, vector<int>& ans){\n    if(root == NULL)\n        return false;\n    \n    ans.push_back(root->data);\n    if(root->data == node_value\n      || path_from_root_helper(root->left, node_value, ans)\n      || path_from_root_helper(root->right, node_value, ans))\n        return true;\n    ans.pop_back();\n    \n    return false;\n}\n\n\nvector<int> path_from_root(node_t* root, int node_value){\n    vector<int> ans;\n    path_from_root_helper(root, node_value, ans);\n    return ans;\n}\n")),(0,o.kt)("h3",{id:"lowest-common-ancestor"},"Lowest common ancestor"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"node with mininum height which is ancestor of the given two nodes")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//if one node is in the tree and other is not then the node in tree is returned\nnode_t* lca(node_t* root, int node1, int node2){\n    if(root == NULL || root->data == node1 || root->data == node2)\n        return root;\n    \n    node_t* left = lca(root->left, node1, node2);\n    node_t* right = lca(root->left, node1, node2);\n    if(left == NULL)\n        return right;\n    if(right == NULL)\n        return left;\n    return root;\n}\n")),(0,o.kt)("h3",{id:"maximum-width-of-tree"},"Maximum width of tree"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"ff39a16389fdb89986c704093aef9f66.png",src:n(4374).Z,width:"1189",height:"595"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"int max_width(node_t* root){\n    if(root == NULL)\n        return 0;\n    queue<pair<node_t*, int>> q;\n    q.push({root, 0});\n    int max_w = 0;\n\n    int cnt = 0;\n    while(!q.empty()){\n        int l_lim = q.front().second, q_size=  q.size();\n        for(int i=0; i<q_size; ++i){\n            auto node = q.front().first;\n            int idx = q.front().second - l_lim;\n            q.pop();\n            if(i == q_size - 1)\n                max_w = max(max_w, idx+1);\n            if(node->left != NULL)\n                q.push({node->left, 2ll*idx + 1 });\n            if(node->right != NULL)\n                q.push({node->right, 2ll*idx + 2 });\n        }\n    }\n    return max_w;\n}\n\n")),(0,o.kt)("h3",{id:"children-sum-problem"},"Children sum problem"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"make binary tree follow this property: ",(0,o.kt)("inlineCode",{parentName:"li"},"node->data = node->left->data + node->right->data")," for all nodes"),(0,o.kt)("li",{parentName:"ul"},"we can increase any node by 1 any number of times to do this")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"void change_tree(node_t* root){\n    if(root == NULL)\n        return;\n    int child_sum = 0;\n    child_sum += (root->left) ? root->left->data : 0;\n    child_sum += (root->right) ? root->right->data : 0;\n    \n    if(child < root->data){\n        if(root->left)\n            root->left->data = root->data;\n        if(root->right)\n            root->right->data = root->data;\n    }\n    else \n        root->data = child;\n    \n    change_tree(root->left);\n    change_tree(root->right);\n    \n    child_sum = 0;\n    child_sum += (root->left) ? root->left->data : 0;\n    child_sum += (root->right) ? root->right->data : 0;\n    if(root->left != NULL or root->right != NULL)\n        root->data = child_sum;\n}\n\n/*\n * par propagates max value found so far down the tree\n * every node data is updated so that its \n */\nint change_tree_helper(node_t* root,int par){\n    if(!root)\n        return 0;\n    int l = change_tree_helper(root->left, max(root->data,par));\n    int r = change_tree_helper(root->right, max(root->data,par));\n    root->data = max(l + r, max(root->data, par));\n    return root->data;\n}\n\nvoid change_tree(BinaryTreeNode < int > * root) {\n    fun(root,0);\n}\n")),(0,o.kt)("h3",{id:"nodes-at-a-distance-k"},"Nodes at a distance k"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"map<node_t*, node_t*> parents_of_nodes(node_t* root){\n    queue<node_t*> q;\n    q.push(root);\n    map<node_t*, node_t*> parents;\n    while(!q.empty()){\n        auto x = q.front();\n        q.pop();\n        if(x->left != NULL){\n            q.push(x->left);\n            parents[x->left] = x;\n        }\n        if(x->right != NULL){\n            q.push(x->right);\n            parents[x->right] =x;\n        }\n    }\n    return parents;\n}\n\nvector<int> distance_k_nodes(node_t* root, node_t* node, int target_dist){\n    vector<int> ans;\n    if(root == NULL || node == NULL)\n        return ans;\n    \n    auto parents = parents_of_nodes(root);\n    unordered_map<node_t*, bool> visited;\n    int dist = 0;\n    queue<node_t*> q;\n    q.push(node);\n    visited[node] = true;\n    while(!q.empty()){\n        if(dist++ == target_dist)\n            break;\n        int q_size = q.size();\n        for(int i=0; i<q_size; ++i){\n            auto x = q.front();q.pop();\n            for(auto t: {x->left, x->right, parents[x]}) \n                if(t && !visited[t]){\n                    q.push(t);\n                    visited[t] = 1;\n                }\n        }\n    }\n    while(!q.empty()) {\n        auto x = q.front(); q.pop();\n        ans.push_back(x->val);\n    }\n    return ans;\n}\n")),(0,o.kt)("h3",{id:"minimum-time-to-burn-tree-from-a-node"},"Minimum time to burn tree from a node"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//i case the only node's data is given, not the pointer\nnode_t* find_node(Node* root, int target){\n    if(root == NULL)\n        return NULL;\n    if(root->data == target)\n        return root;\n    auto x = find_node(root->left, target);\n    if(x != NULL) return x;\n    return find_node(root->right, target);\n}\n\nvector<int> time_to_burn_from_node(node_t* root, node_t* node){\n    if(root == NULL || node == NULL)\n        return 0;\n    \n    auto parents = parents_of_nodes(root);\n    unordered_map<node_t*, bool> visited;\n    \n    int time = 0;\n    queue<node_t*> q;\n    q.push(node);\n    visited[node] = true;\n    while(!q.empty()){\n        int q_size = q.size();\n        bool fl = 0;\n        for(int i=0; i<q_size; ++i){\n            auto x = q.front();q.pop();\n            for(auto t: {x->left, x->right, parents[x]}) \n                if(t && !visited[t]){\n                    q.push(t);\n                    visited[t] = 1;\n                    fl = 1;\n                }\n        }\n        if(fl)\n                time++;\n    }\n    return time;\n}\n")),(0,o.kt)("h3",{id:"count-nodes-in-complete-binary-tree-in-less-than-mathcalon"},"Count nodes in complete binary tree in less than ",(0,o.kt)("span",{parentName:"h3",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"n"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"lg"),(0,o.kt)("mo",{parentName:"mrow"},"\u2061"),(0,o.kt)("mi",{parentName:"mrow"},"N"),(0,o.kt)("msup",{parentName:"mrow"},(0,o.kt)("mo",{parentName:"msup",stretchy:"false"},")"),(0,o.kt)("mn",{parentName:"msup"},"2")),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}((\\lg N)^2)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mop"},"l",(0,o.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),(0,o.kt)("span",{parentName:"span",className:"mclose"},(0,o.kt)("span",{parentName:"span",className:"mclose"},")"),(0,o.kt)("span",{parentName:"span",className:"msupsub"},(0,o.kt)("span",{parentName:"span",className:"vlist-t"},(0,o.kt)("span",{parentName:"span",className:"vlist-r"},(0,o.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,o.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,o.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))," solution")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"int left_height(node_t* root){\n    int height = 0;\n    while(root != NULL)\n        height++, root = root->left;\n    return height;\n}\nint right_height(node_t* root){\n    int height = 0;\n    while(root != NULL)\n        height++, root = root->right;\n    return height;\n}\n//O(lgN)^2 solu\nint node_count_in_complete_tree(node_t* root){\n    if(root == NULL)\n        return 0;\n    int lh = left_height(root), rh = right_height(root);\n    if(lh == rh)\n        return 1<<lh - 1;\n    return 1 + node_count_in_complete_tree(root->left) +\n        node_count_in_complete_tree(root->right);\n}\n")),(0,o.kt)("h3",{id:"construct-binary-tree-from-inorder--preorder-traversal"},"Construct Binary tree from inorder & preorder traversal"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"node_t* construct_h(const vector<int>& pre_order, \n                    const vector<int>& in_order,  \n                    map<int,int>& value_index, \n                    int pre_st, int pre_end, int in_st, int in_end){\n    if(pre_st == pre_end)\n        return NULL;\n    node_t* root = new node_t(pre_order[pre_st]);\n\n    /* auto root_ptr = find(in_order.begin()+in_st, in_order.begin()+in_end, root->data); */ \n    /* int root_location = root_ptr - (in_order.begin() + in_st); */\n    int root_location = value_index[root->data] - in_st;\n\n    root->left = construct_h(pre_order,in_order , value_index,\n                             pre_st+1, pre_st + root_location +1,  \n                             in_st, in_st + root_location);\n    root->right = construct_h(pre_order,in_order, value_index,\n                              pre_st + root_location + 1, pre_end, \n                              in_st + root_location+1 , in_end);\n    return root;\n}\n\nnode_t* construct(const vector<int>& pre_order, const vector<int>& in_order){\n    map<int,int> value_index;\n    for(int i=0; i<in_order.size(); ++i)\n        value_index[in_order[i]] = i;\n\n    return construct_h(pre_order, in_order, value_index, 0, pre_order.size(), 0, in_order.size());\n}\n")),(0,o.kt)("h3",{id:"comstruct-binary-tree-from-inorder--postorder-traversal"},"Comstruct Binary tree from inorder & postorder traversal"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"node_t* construct_h(const vector<int>& post_order, const vector<int>& in_order,  map<int,int>& value_index, int pre_st, int pre_end, int in_st, int in_end){\n    if(pre_st == pre_end)\n        return NULL;\n    node_t* root = new node_t(post_order[pre_end-1]);\n\n    /* auto root_ptr = find(in_order.begin()+in_st, in_order.begin()+in_end, root->data); */ \n    /* int root_location = root_ptr - (in_order.begin() + in_st); */\n    int root_location = value_index[root->data] - in_st;\n\n    root->left = construct_h(post_order,in_order , value_index,\n                           pre_st, pre_st + root_location,  \n                           in_st, in_st + root_location);\n    root->right = construct_h(post_order,in_order, value_index,\n                            pre_st + root_location, pre_end-1, \n                            in_st + root_location+1 , in_end);\n    return root;\n}\n\nnode_t* construct(const vector<int>& in_order, const vector<int>& post_order){\n    map<int,int> value_index;\n    for(int i=0; i<in_order.size(); ++i)\n        value_index[in_order[i]] = i;\n\n    return construct_h(post_order, in_order, value_index, 0, post_order.size(), 0, in_order.size());\n}\n")),(0,o.kt)("h3",{id:"serializing-and-deserializing-a-binary-tree"},"Serializing and Deserializing a binary tree"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'string serialize(node_t* root){\n    if(root == NULL)\n        return "";\n    string res;\n    queue<node_t*> q;\n    q.push(root);\n    while(!q.empty()){\n        auto node = q.front();\n        q.pop();\n        if(node == NULL)\n            res += "#,";\n        else{\n            res += to_string(node->data) + ",";\n            q.push(node->left);\n            q.push(node->right);\n        }\n    }\n    return res;\n}\nnode_t* deserialize(string tree_str){\n    if(tree_str.size() == 0)\n        return NULL;\n    \n    stringstream s(tree_str);\n    string tmp;\n    getline(s, tmp, \',\');\n    node_t* root = new node_t(stoi(tmp)); \n        \n    queue<node_t*> q;\n    q.push(root);\n    while(!q.empty()){\n        auto node = q.front(); q.pop();\n        \n        getline(s, tmp, \',\');\n        if(s != "#"){\n            node->left = new node_t(stoi(temp));\n            q.push(node->left);\n        }\n        getline(s, tmp, \',\');\n        if(s != "#"){\n            node->right = new node_t(stoi(temp));\n            q.push(node->right);\n        }\n    }\n    return root;\n}\n')),(0,o.kt)("h3",{id:"morris-traversal"},"Morris Traversal"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"traversal with ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"n"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))," time and ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mn",{parentName:"mrow"},"1"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(1)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord"},"1"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))," space using threaded binary tree concept")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"idea"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"when you go to left child of the node, find the rightmost node in the left subtree of the node and make its right children point to the node."),(0,o.kt)("li",{parentName:"ul"},"when there is no left child, process the node and go back."),(0,o.kt)("li",{parentName:"ul"},"when going back, we may return back to a traversed node. We'll again perform the first case, but this time we'll find that going right and right we come back to the same node. so break that link and progress further."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"for example here"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"we'll first find the rightmost node in left subtree of root, and point its right to the root."),(0,o.kt)("li",{parentName:"ul"},"now we do the same for  node 2, the rightmost node is 4, make its right point to 2."),(0,o.kt)("li",{parentName:"ul"},"now since node 4 doesn't have a left child so we follow its right child link."),(0,o.kt)("li",{parentName:"ul"},"we come back to 2. now if we go right,right,right in its left subtree then we come back to 2 from 4->2 link, so delete that link and process 2."),(0,o.kt)("li",{parentName:"ul"},"now we proceed in right of node 2. We go to 5, then 6 and then 1."),(0,o.kt)("li",{parentName:"ul"},"when we go right,right,right in left subtree of node 1, then we come back to node 1 through link 6--\x3e1, so delete that link."),(0,o.kt)("li",{parentName:"ul"},"now we proceed to right of 1. 3 doesn't have any left or right child, so process it and traversal is done.")),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("img",{alt:"5d6139f8f7f6a0715611cc0feee9e9d6.png",src:n(1828).Z,width:"416",height:"468"})))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//morris inorder traversal\n//should have put root in a temporary variable and then do this thing\ntemplate<typename Functor>\nvoid traverse(node_t* root, Functor f){\n    while(root != NULL){\n        if(root->left != NULL){\n            auto rightmost = root->left;\n            while(rightmost->right != NULL && rightmost->right != root)\n                rightmost = rightmost->right;\n            if(rightmost->right == root){\n                rightmost->right = NULL;\n                f(root); //x\n                root = root->right;\n            }\n            else{\n                rightmost->right = root;\n                //y\n                root = root->left;\n            }\n        }\n        else{\n            f(root);\n            root = root->right;\n        }\n    }\n}\n//one liner change to convert it to preorder: place line x to line y\n")),(0,o.kt)("h3",{id:"flatten-binary-tree-to-linked-list-in-place"},"Flatten binary tree to linked list in-place"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//O(N) in time and O(h) space, for inorder, doubly\nNode *head = NULL, *previ = NULL;\nvoid flatten(Node* root){\n    if(root == NULL)\n        return;\n\n    helper(root->left);\n    if(previ == NULL){\n        head = root;\n    }\n    else{\n        previ->right = root;\n        root->left = previ;\n    }\n    previ = root;\n    helper(root->right);\n}\n\n\n\n//morris traversal O(1) in space, preorder, singly\nvoid flattern(node_t* root){\n    auto curr = root;\n    while(curr != NULL){\n        if(curr->left != NULL){\n            auto rightmost = curr->left;\n            while(rightmost->right != NULL)\n                rightmost = rightmost->right;\n            rightmost->right = curr->right;\n            curr->right = curr->left;\n            curr->left = NULL;\n        }\n        //when curr->left is not null, then left pointer is moved to right\n        //when curr->left is null, then obviously we'll move to right\n        curr = curr->right;\n    }\n}\n")),(0,o.kt)("h3",{id:"check-if-bt-is-a-bst"},"Check if BT is a BST"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//this can cause problems if INT_MAX or INT_MIN exists in the tree\nbool isBST(node_t* root, data_t min_value = INT_MIN, data_t max_value = INT_MAX){\n    if(root == NULL)\n        return true;\n    \n    return root->data > min_value\n        && root->data < max_value\n        && isBST(root->left, min_value, root->data) \n        && isBST(root->right, root->data, max_value);\n}\n//this works all the time\ntemplate<typename Functor>\nvoid inOrder(node_t* root,Functor&& f){\n    if(root == NULL)\n        return;\n    inOrder(root->left, f);\n    f(root->data);\n    inOrder(root->right, f);\n}\nbool isValidBST(node_t* root) {\n    if (!root)\n        return true;\n    vector<data_t> tree;      \n    inOrder(root, [&](data_t data){ tree.push_back(data); });\n    \n    for (int i=1; i<tree.size(); i++)\n        if (tree[i] <= tree[i-1])\n            return false;\n    return true;\n}\n")))}N.isMDXComponent=!0},1748:function(e,t,n){var a={"./locale":9234,"./locale.js":9234};function r(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=o,e.exports=r,r.id=1748},9245:function(e,t,n){"use strict";t.Z=n.p+"assets/images/45b773669cf24af997237385be7256ce-043b81e31c914119452aa3be65d834e1.png"},1542:function(e,t,n){"use strict";t.Z=n.p+"assets/images/54e4290144c04912be0482a314853db4-4cf67ba4e2b0fac017ef3c644f26b5e8.png"},1828:function(e,t,n){"use strict";t.Z=n.p+"assets/images/9e17211ca26349e39b07348d41eb66f5-099fca1e10e0c944abdff31a90d6f868.png"},8901:function(e,t,n){"use strict";t.Z=n.p+"assets/images/c87e76ba1f604e289f9797369057f951-01b7a49f73658ed42483a8ab09e4a9eb.png"},4374:function(e,t,n){"use strict";t.Z=n.p+"assets/images/d59cbf0cb6654668bd1bb35a2d381d91-6513c079b6493bbf9dc9333a2160dc88.png"}}]);