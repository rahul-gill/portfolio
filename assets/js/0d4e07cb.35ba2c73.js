"use strict";(self.webpackChunkrahul_gill_github_io=self.webpackChunkrahul_gill_github_io||[]).push([[6213],{1899:(a,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>p,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var n=t(7462),s=(t(7294),t(3905)),m=t(4465);const r={title:"Graph Traversal and MST"},p=void 0,l={unversionedId:"dsa/GraphTraversalAndMst",id:"dsa/GraphTraversalAndMst",title:"Graph Traversal and MST",description:"Graph Traversal Problems O(V+E)",source:"@site/docs/dsa/9. GraphTraversalAndMst.md",sourceDirName:"dsa",slug:"/dsa/GraphTraversalAndMst",permalink:"/notes/dsa/GraphTraversalAndMst",draft:!1,editUrl:"https://github.com/rahul-gill/rahul-gill.github.io/issues/new?title=Problem+on+page+deployed+at+/notes/dsa/GraphTraversalAndMst&body=%5Bfile%20to%20be%20edited%5D%28https%3A%2F%2Fgithub.com%2Frahul-gill%2Frahul-gill.github.io%2Ftree%2Fmaster%2Fdocs%2Fdsa/9. GraphTraversalAndMst.md%29",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Graph Traversal and MST"},sidebar:"docs",previous:{title:"Trees",permalink:"/notes/dsa/Trees"},next:{title:"Graph Shortest Path Problems",permalink:"/notes/dsa/GraphShortestPath"}},i={},o=[{value:"Graph Traversal Problems O(V+E)",id:"graph-traversal-problems-ove",level:2},{value:"DFS and BFS",id:"dfs-and-bfs",level:3},{value:"Flood Fill",id:"flood-fill",level:3},{value:"Topological Sort",id:"topological-sort",level:3},{value:"Kahn&#39;s Algorithm",id:"kahns-algorithm",level:4},{value:"Bipartite Graph Check",id:"bipartite-graph-check",level:3},{value:"Graph Edge Properties Check",id:"graph-edge-properties-check",level:3},{value:"Articulation vertices and edges",id:"articulation-vertices-and-edges",level:3},{value:"Kosaraju&#39;s Algorithm for Strongly Connected Components",id:"kosarajus-algorithm-for-strongly-connected-components",level:3}],N={toc:o};function c(a){let{components:e,...t}=a;return(0,s.kt)("wrapper",(0,n.Z)({},N,t,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"graph-traversal-problems-ove"},"Graph Traversal Problems O(V+E)"),(0,s.kt)("h3",{id:"dfs-and-bfs"},"DFS and BFS"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"depth first seach(numbers show when a node was traversed)")),(0,s.kt)(m.G,{config:{},chart:"flowchart TD\n1 --- 2 --- 3 --- 4\n3 --- 5\n1 --- 6 --- 7\n6 --- 8\n8 --- 9",mdxType:"Mermaid"}),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"breadth first search")),(0,s.kt)(m.G,{chart:"flowchart TD\n1 --- 2 --- 4\n2 --- 5\n1 --- 3 --- 6\n3 --- 7 --- 8\n7 --- 9",mdxType:"Mermaid"}),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"algorithms")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'//the true entries in visited array denotes a connected component \n//so can be used for getting connected components\nvector<vector<int>> adj_list;\nint V = adj_list.size();\nvoid dfs(int u){\n    static vector<int> visited(V, 0);\n    visited[u] = 1;\n    cout<<v<<"->";//final op\n    for(auto x:adj_list[u])\n        if(!visited[x]) dfs(x);\n}\n\nvoid bfs(int v){\n    vector<int> visited(V,0);\n    queue<int> q;\n    q.push(v);\n    visited[v] = 1;\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        cout<<u<<"->";//final op\n        for(auto x:adj_list[u])\n            if(!visited[x])\n                q.push(x), visited[x] = 1;\n            \n    }\n}\n')),(0,s.kt)("h3",{id:"flood-fill"},"Flood Fill"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<char>> grid = {\n    {'#','#','#','#','#','#'},\n    {'#','$','$','$','#','#'},\n    {'#','#','$','#','#','#'},\n    {'#','#','$','#','#','#'},\n    {'#','#','$','$','#','#'},\n    {'#','#','#','$','#','#'}\n};\nint C = 6, R = 6;\n//fill c2 in blocks containing c1\n//also counts number of filled pixels; dfs based\nint floodfill(int r, int c, char c1, char c2){\n    //directions\n    static int drow[] = {0, 0,1,1, 1,-1,-1,-1};\n    static int dcol[] = {1,-1,0,1,-1, 0, 1,-1};\n    if(r<0 || r>=R || c<0 || c>=C) return 0;\n    if(grid[r][c] != c1) return 0;\n\n    int ans = 1;\n    grid[r][c] = c2;\n    for(int i=0;i<8;i++)\n        ans += floodfill(r+drow[i], c+dcol[i], c1, c2);\n    return ans;\n}\n")),(0,s.kt)("h3",{id:"topological-sort"},"Topological Sort"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"DAG(directed acyclic graph): directed graph that doesn't contain loops"),(0,s.kt)("li",{parentName:"ul"},"topological sort of DAG: vertices ordering such that for every edge ",(0,s.kt)("inlineCode",{parentName:"li"},"u->v"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"u")," comes before ",(0,s.kt)("inlineCode",{parentName:"li"},"v")," in the ordering")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<int>> adj_list;\nint V = adj_list.size();\n\nstack<int> top_sort;\nvector<int> visited(V, 0);\nvoid dfs_util(int u){\n    visited[u] = 1;\n    for(auto x: adj_list[u]){\n        if(!visited[x])\n            dfs_util(x);\n    }\n    top_sort.push(u);\n}\nvoid topological_sort(){\n    for(int i=0; i<V; i++)\n        if(!visited[i]) \n            dfs_util(i);\n    //final op\n    while(!top_sort.empty()){\n        cout<<top_sort.top()<<\",\";\n        top_sort.pop();\n    }\n    cout<<'\\n';\n}\n")),(0,s.kt)("h4",{id:"kahns-algorithm"},"Kahn's Algorithm"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"topological sort BFS style")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<int>> adj_list;\nint V = adj_list.size();\nvoid kahn_topological_sort(){\n    vector<int> in_degree(V, 0);\n    vector<int> result;\n    for(auto x:adj_list)\n        for(auto y:x)\n            in_degree[y]++;\n\n    queue<int> q;\n    for(int i=0; i<V; i++)\n        if(in_degree[i] == 0) q.push(i);\n\n    while(!q.empty()){\n        int u = q.front();q.pop();\n        result.push_back(u);\n        for(auto neighbor : adj_list[u]){\n            in_degree[neighbor]--;\n            if(in_degree[neighbor] == 0) q.push(neighbor);\n        }\n    }\n    //final op\n    for(auto x:result) cout<<x<<\", \";\n    cout<<'\\n';\n}\n")),(0,s.kt)("h3",{id:"bipartite-graph-check"},"Bipartite Graph Check"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"bipartite graph: such graph that can be divided into two disjoint sets such that every edge will take us from one of the sets to other"),(0,s.kt)("li",{parentName:"ul"},"algorithm uses colors for those two sets")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<int>> adj_list;\nint V = adj_list.size();\nbool bipartite_check(int v = 0){\n    vector<int> color(V,-1);\n    queue<int> q;q.push(v);\n    color[v] = 0;\n\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        for(auto x:adj_list[u]){\n            if(color[x] == -1){\n                q.push(x);\n                color[x] = 1 - color[u];\n            }\n            else if(color[x] == color[u]) return false;      \n        }\n    }\n    return true;\n}\n")),(0,s.kt)("h3",{id:"graph-edge-properties-check"},"Graph Edge Properties Check"),(0,s.kt)(m.G,{chart:"flowchart LR\n    1 --- 2\n    1 --\x3e 3\n    2 --\x3e 4\n    4 --\x3e 6\n    3 --\x3e 5\n    5 --\x3e 7\n    5 --\x3e 8\n    1 -...-> 8\n    6 -..-> 2\n    2 -..-> 5\n",mdxType:"Mermaid"}),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"vetex annotation:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"unvisited: not traversed"),(0,s.kt)("li",{parentName:"ul"},"explore: traversed"),(0,s.kt)("li",{parentName:"ul"},"visited: vertex fully DFSed"))),(0,s.kt)("li",{parentName:"ul"},"in the above diagram",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"solid lines are tree edges"),(0,s.kt)("li",{parentName:"ul"},"1->8 is forward edge"),(0,s.kt)("li",{parentName:"ul"},"2->1 is bidirectional edge"),(0,s.kt)("li",{parentName:"ul"},"2->5 is cross edge"),(0,s.kt)("li",{parentName:"ul"},"6->2 is back edge"))),(0,s.kt)("li",{parentName:"ul"},"one thing: the result depend on the ordering of  ",(0,s.kt)("inlineCode",{parentName:"li"},"adj_list"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'vector<vector<int>> adj_list;\nint V;\nconst int UNVISITED = 0, EXPLORED = 1, VISITED = 2;\nvector<int> parent(V,0), state(V,UNVISITED);\n\nvoid dfs_util(int u){\n    state[u] = EXPLORED;\n    for(auto x: adj_list[u]){\n        if(state[x] == UNVISITED){ //EXPLORED -> UNVISITED\n            printf("\\tTree Edge (%d,%d)\\n",u,x);\n            parent[x] = u;\n            dfs_util(x);\n        }else if(state[x] == EXPLORED){//EXPLORED -> EXPLORED\n            if(x == parent[u]) printf("\\tTwo Way Edge (%d,%d)\\n",u,x);\n            else printf("\\tBack Edge (%d,%d)\\n",u,x);\n        }else if(state[x] == VISITED){//EXPLORED -> VISITED\n            printf("\\tForward/Cross Edge (%d,%d)\\n",u,x);\n        }\n    }\n    state[u] = VISITED;\n}\n\nvoid edge_property_check(){\n    int nComponent = 1;\n    for(int i=0; i<V; i++)\n        if(state[i] == UNVISITED){\n            printf("COMPONENT %d:\\n",nComponent++);\n            dfs_util(i);\n        }\n}\n')),(0,s.kt)("h3",{id:"articulation-vertices-and-edges"},"Articulation vertices and edges"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"articulation point: vertex, removing it disconnects the graph"),(0,s.kt)("li",{parentName:"ul"},"bridge: edge, removing it disconnects the graph"),(0,s.kt)("li",{parentName:"ul"},"algorithm",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"for undirected graph only"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"dfs_num"),": track the iteration counter when a vertex is visited for the first time"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"dfs_low"),": lowest ",(0,s.kt)("inlineCode",{parentName:"li"},"dfs_num")," reachable from current DFS spanning subtree of the vertex\n",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"d"),(0,s.kt)("mi",{parentName:"mrow"},"f"),(0,s.kt)("mi",{parentName:"mrow"},"s"),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"_"),(0,s.kt)("mi",{parentName:"mrow"},"l"),(0,s.kt)("mi",{parentName:"mrow"},"o"),(0,s.kt)("mi",{parentName:"mrow"},"w"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.kt)("mi",{parentName:"mrow"},"u"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"]"),(0,s.kt)("mo",{parentName:"mrow"},"="),(0,s.kt)("mi",{parentName:"mrow"},"m"),(0,s.kt)("mi",{parentName:"mrow"},"i"),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mrow",{parentName:"mrow"},(0,s.kt)("mo",{parentName:"mrow",fence:"true"},"{"),(0,s.kt)("mtable",{parentName:"mrow",rowspacing:"0.36em",columnalign:"left left",columnspacing:"1em"},(0,s.kt)("mtr",{parentName:"mtable"},(0,s.kt)("mtd",{parentName:"mtr"},(0,s.kt)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"false"},(0,s.kt)("mrow",{parentName:"mstyle"},(0,s.kt)("mi",{parentName:"mrow"},"d"),(0,s.kt)("mi",{parentName:"mrow"},"f"),(0,s.kt)("mi",{parentName:"mrow"},"s"),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"_"),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mi",{parentName:"mrow"},"u"),(0,s.kt)("mi",{parentName:"mrow"},"m"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.kt)("mi",{parentName:"mrow"},"u"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"]"))))),(0,s.kt)("mtr",{parentName:"mtable"},(0,s.kt)("mtd",{parentName:"mtr"},(0,s.kt)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"false"},(0,s.kt)("mrow",{parentName:"mstyle"},(0,s.kt)("mi",{parentName:"mrow"},"d"),(0,s.kt)("mi",{parentName:"mrow"},"f"),(0,s.kt)("mi",{parentName:"mrow"},"s"),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"_"),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mi",{parentName:"mrow"},"u"),(0,s.kt)("mi",{parentName:"mrow"},"m"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.kt)("mi",{parentName:"mrow"},"p"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"]")))),(0,s.kt)("mtd",{parentName:"mtr"},(0,s.kt)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"false"},(0,s.kt)("mrow",{parentName:"mstyle"},(0,s.kt)("mtext",{parentName:"mrow"},"for\xa0all\xa0"),(0,s.kt)("mi",{parentName:"mrow"},"p"),(0,s.kt)("mtext",{parentName:"mrow"},"\xa0where\xa0"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"u"),(0,s.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,s.kt)("mi",{parentName:"mrow"},"p"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.kt)("mtext",{parentName:"mrow"},"\xa0is\xa0a\xa0back\xa0edge"))))),(0,s.kt)("mtr",{parentName:"mtable"},(0,s.kt)("mtd",{parentName:"mtr"},(0,s.kt)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"false"},(0,s.kt)("mrow",{parentName:"mstyle"},(0,s.kt)("mi",{parentName:"mrow"},"d"),(0,s.kt)("mi",{parentName:"mrow"},"f"),(0,s.kt)("mi",{parentName:"mrow"},"s"),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"_"),(0,s.kt)("mi",{parentName:"mrow"},"l"),(0,s.kt)("mi",{parentName:"mrow"},"o"),(0,s.kt)("mi",{parentName:"mrow"},"w"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.kt)("mi",{parentName:"mrow"},"v"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"]")))),(0,s.kt)("mtd",{parentName:"mtr"},(0,s.kt)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"false"},(0,s.kt)("mrow",{parentName:"mstyle"},(0,s.kt)("mtext",{parentName:"mrow"},"for\xa0all\xa0"),(0,s.kt)("mi",{parentName:"mrow"},"v"),(0,s.kt)("mtext",{parentName:"mrow"},"\xa0where\xa0"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"u"),(0,s.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,s.kt)("mi",{parentName:"mrow"},"v"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.kt)("mtext",{parentName:"mrow"},"\xa0is\xa0a\xa0tree\xa0edge")))))))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"dfs\\_low[u] = min \\begin{cases}  dfs\\_num[u]\\\\  dfs\\_num[p] & \\text{for all }p\\text{ where }(u,p)\\text{ is a back edge}\\\\ dfs\\_low[v] & \\text{for all }v\\text{ where }(u,v)\\text{ is a tree edge} \\end{cases}")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.06em",verticalAlign:"-0.31em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"df"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"s"),(0,s.kt)("span",{parentName:"span",className:"mord",style:{marginRight:"0.02778em"}},"_"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02691em"}},"w"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"["),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"]"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"="),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"4.32em",verticalAlign:"-1.91em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"min"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"minner"},(0,s.kt)("span",{parentName:"span",className:"mopen"},(0,s.kt)("span",{parentName:"span",className:"delimsizing mult"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"2.35em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.2em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.15em"}}),(0,s.kt)("span",{parentName:"span",className:"delimsizinginner delim-size4"},(0,s.kt)("span",{parentName:"span"},"\u23a9"))),(0,s.kt)("span",{parentName:"span",style:{top:"-2.192em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.15em"}}),(0,s.kt)("span",{parentName:"span",style:{height:"0.316em",width:"0.8889em"}},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"0.8889em",height:"0.316em",style:{width:"0.8889em"},viewBox:"0 0 888.89 316",preserveAspectRatio:"xMinYMin"},(0,s.kt)("path",{parentName:"svg",d:"M384 0 H504 V316 H384z M384 0 H504 V316 H384z"})))),(0,s.kt)("span",{parentName:"span",style:{top:"-3.15em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.15em"}}),(0,s.kt)("span",{parentName:"span",className:"delimsizinginner delim-size4"},(0,s.kt)("span",{parentName:"span"},"\u23a8"))),(0,s.kt)("span",{parentName:"span",style:{top:"-4.292em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.15em"}}),(0,s.kt)("span",{parentName:"span",style:{height:"0.316em",width:"0.8889em"}},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"0.8889em",height:"0.316em",style:{width:"0.8889em"},viewBox:"0 0 888.89 316",preserveAspectRatio:"xMinYMin"},(0,s.kt)("path",{parentName:"svg",d:"M384 0 H504 V316 H384z M384 0 H504 V316 H384z"})))),(0,s.kt)("span",{parentName:"span",style:{top:"-4.6em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.15em"}}),(0,s.kt)("span",{parentName:"span",className:"delimsizinginner delim-size4"},(0,s.kt)("span",{parentName:"span"},"\u23a7")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.85em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mtable"},(0,s.kt)("span",{parentName:"span",className:"col-align-l"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"2.41em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-4.41em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.008em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"df"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"s"),(0,s.kt)("span",{parentName:"span",className:"mord",style:{marginRight:"0.02778em"}},"_"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"["),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"]"))),(0,s.kt)("span",{parentName:"span",style:{top:"-2.97em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.008em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"df"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"s"),(0,s.kt)("span",{parentName:"span",className:"mord",style:{marginRight:"0.02778em"}},"_"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"["),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"]"))),(0,s.kt)("span",{parentName:"span",style:{top:"-1.53em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.008em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"df"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"s"),(0,s.kt)("span",{parentName:"span",className:"mord",style:{marginRight:"0.02778em"}},"_"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02691em"}},"w"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"["),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"]")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.91em"}},(0,s.kt)("span",{parentName:"span"}))))),(0,s.kt)("span",{parentName:"span",className:"arraycolsep",style:{width:"1em"}}),(0,s.kt)("span",{parentName:"span",className:"col-align-l"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.97em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.97em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.008em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord text"},(0,s.kt)("span",{parentName:"span",className:"mord"},"for\xa0all\xa0")),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"mord text"},(0,s.kt)("span",{parentName:"span",className:"mord"},"\xa0where\xa0")),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,s.kt)("span",{parentName:"span",className:"mpunct"},","),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"),(0,s.kt)("span",{parentName:"span",className:"mord text"},(0,s.kt)("span",{parentName:"span",className:"mord"},"\xa0is\xa0a\xa0back\xa0edge")))),(0,s.kt)("span",{parentName:"span",style:{top:"-1.53em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3.008em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord text"},(0,s.kt)("span",{parentName:"span",className:"mord"},"for\xa0all\xa0")),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,s.kt)("span",{parentName:"span",className:"mord text"},(0,s.kt)("span",{parentName:"span",className:"mord"},"\xa0where\xa0")),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,s.kt)("span",{parentName:"span",className:"mpunct"},","),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"),(0,s.kt)("span",{parentName:"span",className:"mord text"},(0,s.kt)("span",{parentName:"span",className:"mord"},"\xa0is\xa0a\xa0tree\xa0edge"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.91em"}},(0,s.kt)("span",{parentName:"span"}))))))),(0,s.kt)("span",{parentName:"span",className:"mclose nulldelimiter"}))))))),(0,s.kt)("li",{parentName:"ul"},"there's a back edge from ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"u")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u")))))," or its descendants to one of its ancestors if and only if:\nvertex ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"u")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u")))))," has a child ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"v")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"v")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v")))))," for which ",(0,s.kt)("inlineCode",{parentName:"li"},"dfs_low[v]<=dfs_num[u]"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"the back edge comes back to ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"u")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u")))))," if ",(0,s.kt)("inlineCode",{parentName:"li"},"dfs_low[v]==dfs_num[u]")),(0,s.kt)("li",{parentName:"ul"},"so an edge ",(0,s.kt)("inlineCode",{parentName:"li"},"(u,v)")," is bridge if ",(0,s.kt)("inlineCode",{parentName:"li"},"dfs_low[v]>dfs_num[u]")))),(0,s.kt)("li",{parentName:"ul"},"at first ",(0,s.kt)("inlineCode",{parentName:"li"},"dfs_low[u]\t== dfs_num[u]")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"dfs_low[u]")," become smaller when a cycle is encountered ")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<int>> adj_list;\nint V;\nvector<int> tin, low;\nint timer;\nvoid dfs(int v, int p = -1) {\n    tin[v] = low[v] = timer++;\n    for (int to : adj_list[v]) {\n        if (to == p) continue;\n        if (tin[to] == -1) low[v] = min(low[v], tin[to]);\n        else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v]) IS_BRIDGE(v, to);//main op\n        }\n    }\n}\nvoid find_bridges() {\n    timer = 0;\n    tin.assign(V, -1);\n    low.assign(V, -1);\n    for (int i = 0; i < V; ++i) {\n        if (tin[i] == -1) dfs(i);\n    }\n}\n")),(0,s.kt)("h3",{id:"kosarajus-algorithm-for-strongly-connected-components"},"Kosaraju's Algorithm for Strongly Connected Components"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"stack<int> stk;\nvector<int> visited(V,0);\nvector<vector<int>> adj_list_transpose(V);\nvoid dfs_util(int u){\n    visited[u] = 1;\n    for(auto x:adj_list[u])\n        if(!visited[x]) dfs_util(x);\n    stk.push(u);\n}\nvoid dfs_util2(int u){\n    visited[u] = 1;\n    cout<<u<<\", \";\n    for(auto x:adj_list_transpose[u])\n        if(!visited[x]) dfs_util2(x);\n}\nvoid kosaraju_algorithm(){\n    for(int i=0; i<V; i++)\n        if(!visited[i]) dfs_util(i);\n\n    visited.assign(V,0);\n    for(int i=0; i<V; i++)\n        for(auto neighbor:adj_list[i])\n            adj_list_transpose[neighbor].push_back(i);\n    \n    while(!stk.empty()){\n        int v = stk.top(); stk.pop();\n        if(!visited[v]){\n            dfs_util2(v);\n            cout<<'\\n';\n        }\n    }\n}\n")))}c.isMDXComponent=!0}}]);