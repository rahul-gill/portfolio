"use strict";(self.webpackChunkrahul_gill_github_io=self.webpackChunkrahul_gill_github_io||[]).push([[5725],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(a),u=r,h=d["".concat(o,".").concat(u)]||d[u]||c[u]||s;return a?n.createElement(h,i(i({ref:t},m),{},{components:a})):n.createElement(h,i({ref:t},m))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6921:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const s={title:"Processes and threads"},i=void 0,l={unversionedId:"os/Processes",id:"os/Processes",title:"Processes and threads",description:"Introduction",source:"@site/docs/os/2. Processes.md",sourceDirName:"os",slug:"/os/Processes",permalink:"/notes/os/Processes",draft:!1,editUrl:"https://github.com/rahul-gill/rahul-gill.github.io/issues/new?title=Problem+on+page+deployed+at+/notes/os/Processes&body=%5Bfile%20to%20be%20edited%5D%28https%3A%2F%2Fgithub.com%2Frahul-gill%2Frahul-gill.github.io%2Ftree%2Fmaster%2Fdocs%2Fos/2. Processes.md%29",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Processes and threads"},sidebar:"docs",previous:{title:"Operating System Introduction",permalink:"/notes/os/Intro"},next:{title:"Scheduling",permalink:"/notes/os/Scheduling"}},o={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Creating processes",id:"creating-processes",level:2},{value:"Inter-process communication",id:"inter-process-communication",level:2},{value:"Threads",id:"threads",level:2},{value:"Implicit threading",id:"implicit-threading",level:3}],m={toc:p};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"process"),": running/executing instance of a program"),(0,r.kt)("li",{parentName:"ul"},"there can be multiple processes of single program at the same time",(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"jobs"),": unit used as cpu usage ")))),(0,r.kt)("p",null,"TODO: meaning of different process state\nTODO: explaination of proc struct"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"process control block(PCB)"),": data stucture containing info about process resources:  program counter, registers, state(running/queued/waiting/terminated etc.),global data section, scheduling info, mem management info, accounting info(process id, limits etc.), io info(list of open files etc.), threads info etc.\nfor example:"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"thread"),": execution units, have some process resources shared between them"),(0,r.kt)("li",{parentName:"ul"},"in linux",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"PCB data structure: ",(0,r.kt)("inlineCode",{parentName:"li"},"task_struct")," in header file ",(0,r.kt)("inlineCode",{parentName:"li"},"sched.h")),(0,r.kt)("li",{parentName:"ul"},"these PCBs kept in a doubly linked list maintained by kernel"),(0,r.kt)("li",{parentName:"ul"},"no differentiation between process and threads(parent-child hierarchy of processes)")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct context{\n    int eip, esp, ebp;\n    int ebx, ecx, edx;\n    int esi,edi;\n};\nenum proc_state{\n    UNUSED, SLEEPING, RUNNABLE, RUNNING, EMBRYO, ZOMBIE\n};\nstruct proc{\n    char *mem;         // start of process memory\n    uint sz;           // size of process memory\n    char *kstack;      // bottom of kernel stack\n    enum proc_state state;\n    int pid;\n    struct proc *parent;\n    int killed;        // if zero, the process was killed\n    struct file *oflie[NO_FILE];\n    struct inode *cwd; //current working directory\n    /* context is used in context switching(giving cpu to other process)\n     * trapframe holds state when an exception arise\n     */\n    struct context context;\n    struct trapframe *tf;\n    /* chan: channel, sleeping on chan if points to NULL\n     *useful when for example process sleeps waiting for an input in console\n     */\n    void *chan;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"process dispatched: process selected for execution; dispatcher does that"),(0,r.kt)("li",{parentName:"ul"},"long term scheduler(controls the degree of multiprogramming: number of processes in main memory) and short term scheduler(schedules cpu usage)"),(0,r.kt)("li",{parentName:"ul"},"medium term scheduler(swaps out to disk and load back in memory a process when there's a need; for example: when my ram can't handle android studio so somethings are swapped out to disk)"),(0,r.kt)("li",{parentName:"ul"},"cpu bound(mostly cpu) and io bound(mostly do io) process; processes can also be cpu and io heavy at the same time"),(0,r.kt)("li",{parentName:"ul"},"context of process and context switch"),(0,r.kt)("li",{parentName:"ul"},"ios have limited background process support but android have application component names ",(0,r.kt)("inlineCode",{parentName:"li"},"Service")," which can be used for doing background tasks")),(0,r.kt)("h2",{id:"creating-processes"},"Creating processes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"process creation steps:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"pid and a process-table entry is created and assigned to the process"),(0,r.kt)("li",{parentName:"ul"},"code and static data is loaded in memory(lazily)"),(0,r.kt)("li",{parentName:"ul"},"memory for stack is allocated and stack is intialized with argumetns of main function"),(0,r.kt)("li",{parentName:"ul"},"heap memory is allocated"),(0,r.kt)("li",{parentName:"ul"},"other tasks such as setting up 3 file descriptors: stdin, stdout, stderr etc. are done"),(0,r.kt)("li",{parentName:"ul"},"process is scheduled to run(later or immedietly depending on cpu load)"))),(0,r.kt)("li",{parentName:"ul"},"in linux there's a process which is parent of all process like init, openrc, systemd\nfor example using ",(0,r.kt)("inlineCode",{parentName:"li"},"pstree")," command on manjaro we get somthing like this")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"systemd\u2500\u252c\u2500NetworkManager\u2500\u2500\u25002*[{NetworkManager}]\n        \u251c\u2500kdeinit5\u2500\u252c\u25002*[file.so]\n        \u2502          \u2514\u2500klauncher\u2500\u2500\u25002*[{klauncher}]\n        \u251c\u2500kwin_x11\u2500\u2500\u25009*[{kwin_x11}]\n        \u251c\u2500org_kde_powerde\u2500\u2500\u25006*[{org_kde_powerde}]\n        \u251c\u2500plasmashell\u2500\u252c\u2500dolphin\u2500\u2500\u25005*[{dolphin}]\n        \u2502             \u251c\u2500konsole\u2500\u252c\u2500zsh\u2500\u2500\u2500pstree\n        \u2502             \u2502         \u2514\u25007*[{konsole}]\n        \u2502             \u251c\u2500ksysguardd\n        \u2502             \u2514\u250010*[{plasmashell}]\n        \u251c\u2500sddm\u2500\u252c\u2500Xorg\u2500\u2500\u25002*[{Xorg}]\n        \u2502      \u251c\u2500sddm-helper\u2500\u2500\u2500startplasma-x11\u2500\u2500\u2500{startplasma-x11}\n        \u2502      \u2514\u2500{sddm}\n        \u251c\u2500start_kdeinit\n        \u251c\u2500systemd\u2500\u252c\u2500(sd-pam)\n        \u2502         \u251c\u2500dbus-daemon\n        \u2502         \u251c\u2500dconf-service\u2500\u2500\u25002*[{dconf-service}]\n        \u2502         \u251c\u2500kscreen_backend\u2500\u2500\u25002*[{kscreen_backend}]\n        \u2502         \u251c\u2500pulseaudio\u2500\u2500\u25002*[{pulseaudio}]                  \n        \u251c\u2500systemd-journal\n        \u251c\u2500systemd-logind\n        \u251c\u2500systemd-machine\n        \u251c\u2500systemd-timesyn\u2500\u2500\u2500{systemd-timesyn}\n        \u2514\u2500systemd-udevd\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"creating a child process in linux")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\nint main(){\n    pid_t pid;\n    /* fork lazily clones the current process as a new child */\n    pid = fork();\n    if (pid < 0) { \n        fprintf(stderr, "Fork Failed");\n        exit(1); // exit can be used to terminate process \n    }\n    else if (pid == 0) { /* child process */\n        /*the child will mutate into ls command?*/\n        execlp("/bin/ls","ls",NULL);\n    }\n    else { /* parent process */\n        /* wait for the child to complete */\n        wait(NULL);\n        printf("Child Complete");\n    }\n    return 0;\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"in windows")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <windows.h>\nint main(void){\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    // allocate memory\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    ZeroMemory(&pi, sizeof(pi));\n    \n    // CreateProcess doesn\'t clone\n    if (!CreateProcess(\n        NULL, /*app name*/\n        "C:\\\\WINDOWS\\\\system32\\\\mspaint.exe", /* command */\n        NULL, /* don\u2019t inherit process handle */\n        NULL, /* don\u2019t inherit thread handle */\n        FALSE, /* disable handle inheritance */\n        0, /* no creation flags */\n        NULL, /* use parent\u2019s environment block */\n        NULL, /* use parent\u2019s existing directory */\n        &si,\n        &pi\n    )){\n        fprintf(stderr, "Create Process Failed");\n        return -1;\n    }\n    // pass handle of child and wait infinitely for its completion\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    printf("Child Complete");\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cascading termination: system don't allow children to exist if parent is terminated"),(0,r.kt)("li",{parentName:"ul"},"when a  process terminates, its resources are deallocated by system but its entry in the process table remain there until the parent calls ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()"),", because the process table contains the process\u2019s exit status. If parent has not yet called ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()"),"  and process terminates then its called as ",(0,r.kt)("strong",{parentName:"li"},"zombie")," process. For example when in the above code, if we do not call ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," and before the final return, add a line ",(0,r.kt)("inlineCode",{parentName:"li"},'scanf("%d",&x);')," you'll see whats happening."),(0,r.kt)("li",{parentName:"ul"},"if parent didn't called ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," and gets terminated, the children are left ",(0,r.kt)("strong",{parentName:"li"},"orphans"),". Linux address this scenario by assigning init process as the new parent to orphan processes. The init process periodically calles ",(0,r.kt)("inlineCode",{parentName:"li"},"wait()")," to collect exit status of terminated processes and releasing their pid and process-table entry.")),(0,r.kt)("h2",{id:"inter-process-communication"},"Inter-process communication"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"cooperating processes")," are those which can be affected by some other processes, for example when two processes share data."),(0,r.kt)("li",{parentName:"ul"},"two models of IPC: shared memory and message passing. Shared memory is fast because message passing is done via system calls. Message passing is easier for sharing small amount of data."),(0,r.kt)("li",{parentName:"ul"},"shared memory can cause cache coherency issue in a multi-core systems"),(0,r.kt)("li",{parentName:"ul"},"producer-consumer process",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"two processes shares a circular buffer ",(0,r.kt)("inlineCode",{parentName:"li"},"struct item buffer[BUFFER_SIZE]"),"; an integer ",(0,r.kt)("inlineCode",{parentName:"li"},"in")," denotes the next free position and integer ",(0,r.kt)("inlineCode",{parentName:"li"},"out")," denotes first full position in buffer."),(0,r.kt)("li",{parentName:"ul"},"buffer is empty when ",(0,r.kt)("inlineCode",{parentName:"li"},"in==out")," and full when ",(0,r.kt)("inlineCode",{parentName:"li"},"(in+1) % BUFFER_SIZE == out"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"//producer\nstruct item next_produced;\nwhile (true) {\n    while (((in + 1) % BUFFER SIZE) == out)\n        ;\n    buffer[in] = next produced;\n    in = (in + 1) % BUFFER SIZE ;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"//consumer\nstruct item next_consumed;\nwhile (true) {\n    while (in == out)\n        ;\n    next consumed = buffer[out];\n    out = (out + 1) % BUFFER SIZE;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"one issue here is situation when both producer and consumer attempt to access the buffer concurrently; also the ",(0,r.kt)("inlineCode",{parentName:"li"},"while")," thing is not good.",(0,r.kt)("br",null)),(0,r.kt)("li",{parentName:"ul"},"message passing through ports such as in jupyter notebook. This can also be used to pass messages to processes on other devices such as adb shell passing messages to android phone."),(0,r.kt)("li",{parentName:"ul"},"POSIX shared memory is organized using memory-mapped files, which associate the region of shared memory with a file. example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"//common headers to be included\n#include<stdio.h>\n#include<sys/mman.h>\n#include<sys/stat.h>        /* For mode constants */\n#include<fcntl.h>           /* For O_* constants */\n#include<unistd.h>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'//producer\n//create a shared memory object; \n//signature: int shm_open(const char *name, int oflag, mode_t mode);\nint shm_fd = shm_open("axb", O_CREAT | O_RDWR, 0666);   \n//configure the size of object in bytes\nftruncate(shm_fd, 4096);\nvoid *ptr = mmap(0, 4096, PROT_WRITE, MAP_SHARED, shm_fd, 0);\n\n/* write to the shared memory object */\nsprintf(ptr,"%s","hi ");\nptr += 3;\nsprintf(ptr,"%s","hello");\nptr += 5;\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'//consumer\nint shm_fd = shm_open("axb", O_RDONLY, 0666);\nvoid *ptr = mmap(0, 4096, PROT_READ, MAP_SHARED, shm_fd, 0);\nprintf("%s",(char *)ptr);\nshm_unlink("axb");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pipes: producer write to one end and consumer reads on teh other end; unix pipe call",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"in command line ",(0,r.kt)("inlineCode",{parentName:"li"},"ls -lah | grep myfile"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'//int pipe(int fd_arr[2]); //fd_arr[0]:read-end, fd_arr[1]:write-end\n#include <stdlib.h>\n#include <unistd.h>\nint main(){\n    int fildes[2];\n    const int BSIZE = 100;\n    char buf[BSIZE];\n    ssize_t nbytes;\n    int status;\n\n    status = pipe(fildes);\n    if (status == -1 ){\n        fprintf(stderr, "error occured");\n        exit(1);\n    }\n\n    switch (fork()) {\n    case -1:\n        fprintf(stderr, "error occured");\n        exit(1);\n        break;\n    case 0:  /* Child - reads from pipe */\n       close(fildes[1]);                       /* Write end is unused */\n       nbytes = read(fildes[0], buf, BSIZE);   /* Get data from pipe */\n       /* At this point, a further read would see end-of-file ... */\n       close(fildes[0]);                       /* Finished with pipe */\n       exit(EXIT_SUCCESS);\n\n    default:  /* Parent - writes to pipe */\n       close(fildes[0]);                       /* Read end is unused */\n       write(fildes[1], "Hello world\\n", 12);  /* Write data on pipe */\n       close(fildes[1]);                       /* Child will see EOF */\n       exit(EXIT_SUCCESS);\n    }\n}\n')),(0,r.kt)("h2",{id:"threads"},"Threads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"different execution units of same process")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a process can have multiple threads")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"have its own program counter, registers state and stack but other resources such as memory and static data are shared")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"so now process can have multiple stacks but those stacks are usually small")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"benefits of threads"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"responsiveness: time-consuming task done on other thread so it doesn't block the ui thread"),(0,r.kt)("li",{parentName:"ul"},"resource sharing between threads"),(0,r.kt)("li",{parentName:"ul"},"economical: doesn't require to allocate new resources for it because threads share resources"),(0,r.kt)("li",{parentName:"ul"},"better performance: threads can run on different cores in parallel"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Amdahl's law: if ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"S")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"S")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"S")))))," is proportion of application which needs to be performed serially on a system with ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"N")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," processing cores, then speedup done by adding more cores is ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mo",{parentName:"mrow"},"\u2264"),(0,r.kt)("mfrac",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"mfrac"},"N"),(0,r.kt)("mrow",{parentName:"mfrac"},(0,r.kt)("mi",{parentName:"mrow"},"N"),(0,r.kt)("mi",{parentName:"mrow"},"S"),(0,r.kt)("mo",{parentName:"mrow"},"+"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mn",{parentName:"mrow"},"1"),(0,r.kt)("mo",{parentName:"mrow"},"\u2212"),(0,r.kt)("mi",{parentName:"mrow"},"S"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\leq \\frac{N}{NS+(1-S)}")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7719em",verticalAlign:"-0.136em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2264"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.3923em",verticalAlign:"-0.52em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,r.kt)("span",{parentName:"span",className:"mfrac"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8723em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.655em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.05764em"}},"NS"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"+"),(0,r.kt)("span",{parentName:"span",className:"mopen mtight"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"\u2212"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.05764em"}},"S"),(0,r.kt)("span",{parentName:"span",className:"mclose mtight"},")")))),(0,r.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,r.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.10903em"}},"N"))))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.52em"}},(0,r.kt)("span",{parentName:"span"}))))),(0,r.kt)("span",{parentName:"span",className:"mclose nulldelimiter"})))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"processor threads and hyper-threading(like intel says 8 cores 16 threads):\nFor each processor core, the OS addresses two virtual(logical) cores and shares the workload between them. Both have their own processor state and both can be individually halted, interrupted or directed to execute a specified thread.One physical core appears as two processors to the OS, allowing concurrent scheduling of two processes per core.Certain sections of the processor are duplicate that store the architectural state but main execution resources, caches etc. are shared.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"challenges in programming for multicore systems"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"identifying tasks that can be executed in parallel"),(0,r.kt)("li",{parentName:"ul"},"handling splitting and sync of data accessed and manipulated by tasks"),(0,r.kt)("li",{parentName:"ul"},"testing and debugging"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"there are two kinds of threads: user threads and kernel threads. User threads are maintained by some thread library and kernel threads are maintained by kernel. user threads need to be mapped to kernel threads to be executed")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"thread models"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"one to one model: 1:1 relationship between kernel and user threads"),(0,r.kt)("li",{parentName:"ul"},"many to many model"),(0,r.kt)("li",{parentName:"ul"},"many to one model: many user threads mapped to single kernel thread"),(0,r.kt)("li",{parentName:"ul"},"two level model: hybrid of 1:1 and m:n model"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"https://c9x.me/articles/gthreads/intro.html"},"green threads"),": user mode threads, many to one model, useful when doing io tasks. The article is amazing.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"pthread library for threads(NPTL implementation in linux 1:1 type so a new thread -> a new process)"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'int pnum = 0; /* shared by the threads */\nstatic const int tot = 100;\nvoid *runner(void *param);\n\nint main(int argc, char *argv[]){\n    pthread_t tid[tot];\n    pthread_attr_t attr;\n\n    pthread_attr_init(&attr);\n    //pthread_create\'s last argument(arguments for runner) are void* but cheated I\n    for(int i=0; i<tot; i++)\n        pthread_create(&tid[i],&attr,runner,i);\n    for(int i=0; i<tot; i++)\n        pthread_join(tid[i],NULL);\n    printf("done\\n");\n}\n\nvoid *runner(void *param){\n    printf("thread no. %d\\n", param);\n    pthread_exit(0);\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clone")," sycall is used for thread type of things in linux",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"it provides precise control over what pieces of execution context are shared between the calling process and the child process."),(0,r.kt)("li",{parentName:"ul"},"It uses flags such as ",(0,r.kt)("inlineCode",{parentName:"li"},"CLONE_FS"),"(file system shared),  ",(0,r.kt)("inlineCode",{parentName:"li"},"CLONE_VS"),"(memory space shared),  ",(0,r.kt)("inlineCode",{parentName:"li"},"CLONE_SIGHAND"),"(signal handlers shared),  ",(0,r.kt)("inlineCode",{parentName:"li"},"CLONE_FILES"),"(open files shared)")))),(0,r.kt)("h3",{id:"implicit-threading"},"Implicit threading"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"passing thread creation and management responsibilities to compilers and run time library"),(0,r.kt)("li",{parentName:"ul"},"thread pools: create a number of threads at process startup and place them into a pool.If some work needs to be done, a thread from this pool is awakened and passed the work, if one is available. If no thread is available, the sysem waits until one becomes free"),(0,r.kt)("li",{parentName:"ul"},"benefits of thread pools",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"limits the number of threads existing at a time instance. For example if server creates a new thread for each request, then som many concurrent requests can create so many threads exhausting sytem resources"),(0,r.kt)("li",{parentName:"ul"},"faster because the thread to be used is already created"),(0,r.kt)("li",{parentName:"ul"},"seperating different kinds of tasks(for example in android there are thread pools: main for cpu heavy work, io and ui.). Different thread pools handle the executions differently"))),(0,r.kt)("li",{parentName:"ul"},"number of threads in pools can be heuristically determined or can be adjusted dynamically according to usage patterns."),(0,r.kt)("li",{parentName:"ul"},"openmp example: summing elements of two arrays")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include<omp.h>\n#pragma omp parallel for\nfor (i = 0; i < N; i++) {\n    c[i] = a[i] + b[i];\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"grand central dispatch(apple thing)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"two types of dispatch queues: serial and concurrent"),(0,r.kt)("li",{parentName:"ul"},"three types of priorities: low, default and high"),(0,r.kt)("li",{parentName:"ul"},"example")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-c"},'dispatch_queue_t queue = dispatch_get_global_queue(\n    DISPATCH_QUEUE PRIORITY_DEFAULT, 0);\ndispatch async(queue, \u02c6{ printf("I am a block."); });\n'))),(0,r.kt)("li",{parentName:"ul"},"kotlin coroutines and goroutines??"),(0,r.kt)("li",{parentName:"ul"},"challenges with threads",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"should fork clone the forking thread only or all threads"),(0,r.kt)("li",{parentName:"ul"},"how threads handle signals"),(0,r.kt)("li",{parentName:"ul"},"how threads are cancelled: deffered cancellation(target thread periodically checks if it should terminate) or asynchronous cancellation(immediate termination; can be disaster)"),(0,r.kt)("li",{parentName:"ul"},"so pthread uses ",(0,r.kt)("inlineCode",{parentName:"li"},"pthread_cancel")," which requests the thread to be cancelled and to check if it cancelled, it must be joined with. The thread checks for this requests at certain points in programs(called cancellation points) and thread can install a function(cleanup handlers) to be executed before it cancels. A number of functions are cancellation points like ",(0,r.kt)("inlineCode",{parentName:"li"},"pthread_testcancel"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"pthread_cond_wait")," etc."),(0,r.kt)("li",{parentName:"ul"},"thread local storage(different from local variables)"),(0,r.kt)("li",{parentName:"ul"},"communication between thread library and kernel"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"LWP(lighweight process)"),": Many systems implementing either the many-to-many or the two-level model place an this intermediate data structure between the user and kernel threads.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"To the user-thread library, the LWP appears to be a virtual processor on which the application can schedule a user thread to run."),(0,r.kt)("li",{parentName:"ul"},"Each LWP is attached to a kernel thread which os  schedules to run on physical processors"),(0,r.kt)("li",{parentName:"ul"},"if kernel thread blocks then LWP blocks and then user thread blocks"),(0,r.kt)("li",{parentName:"ul"},"app may require any number of LWPs to run efficiently"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scheduler activation")," a scheme for communication between user-thread library and kernel",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"kernel provides app with a set of virtual processors(LWPs) on which the app can schedule user threads"),(0,r.kt)("li",{parentName:"ul"},"kernel informs the app about certain events with a proceducer named ",(0,r.kt)("strong",{parentName:"li"},"upcall")),(0,r.kt)("li",{parentName:"ul"},"thread library have upcall handlers which handle the upcall and run on some virtual processor"))),(0,r.kt)("li",{parentName:"ul"},"scenario: some thread is about to block",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"kernel makes an upcall to the app informing it that a thread is about to block and identifies the specific thread."),(0,r.kt)("li",{parentName:"ul"},"kernel allocates new virtual processor for the application"),(0,r.kt)("li",{parentName:"ul"},"app run the upcall handler on this new virtual processor"),(0,r.kt)("li",{parentName:"ul"},"upcall handler saves the state of the blocking thread and then schedules another thread to run"))),(0,r.kt)("li",{parentName:"ul"},"scenario: the event that the blocking thread was waiting for occurs",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"first 3 steps same as above"),(0,r.kt)("li",{parentName:"ul"},"upcall handler schedules the unblocked thread")))))}c.isMDXComponent=!0}}]);