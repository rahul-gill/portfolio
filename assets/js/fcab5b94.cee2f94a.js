(self.webpackChunkrahul_gill_github_io=self.webpackChunkrahul_gill_github_io||[]).push([[6394],{2502:function(e,n,t){"use strict";t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return c},default:function(){return v},frontMatter:function(){return r},metadata:function(){return u},toc:function(){return f}});var o=t(7462),i=t(3366),a=(t(7294),t(3905)),s=t(3456),l=["components"],r={title:"App Architecture"},c=void 0,u={unversionedId:"mobile-app-dev/Architecture",id:"mobile-app-dev/Architecture",title:"App Architecture",description:"MVVM",source:"@site/docs/mobile-app-dev/Architecture.md",sourceDirName:"mobile-app-dev",slug:"/mobile-app-dev/Architecture",permalink:"/docs/mobile-app-dev/Architecture",tags:[],version:"current",frontMatter:{title:"App Architecture"},sidebar:"docs",previous:{title:"App Ideas",permalink:"/docs/mobile-app-dev/Apps"},next:{title:"UI UX",permalink:"/docs/mobile-app-dev/UiUx"}},d={},f=[{value:"MVVM",id:"mvvm",level:2},{value:"Unidirectional data flow",id:"unidirectional-data-flow",level:2},{value:"Compose, ViewModel implementation",id:"compose-viewmodel-implementation",level:3}],p={toc:f};function v(e){var n=e.components,t=(0,i.Z)(e,l);return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"mvvm"},"MVVM"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"model, view, view-model")),(0,a.kt)(s.Mermaid,{config:{mermaid:{theme:"dark"}},chart:'flowchart TD\n\tView-- UI events by user --\x3eViewModel\n\tViewModel-- State update --\x3eView\n\tViewModel<-- Get core business logic methods--\x3eRepository\n\t\n  \n  subgraph OfflineStorage\n\t\tRoom\n\t\tKeyValueStore\n  end\n  \n  subgraph RemoteDataSource\n\t\tRetrofit\n  end\n  \n  c3(("webservice"))\n  db[("Storage/SQLite")]\n  \n  Repository --\x3e OfflineStorage\n  Repository --\x3e RemoteDataSource\n  OfflineStorage --\x3e db\n  RemoteDataSource --\x3e c3',mdxType:"Mermaid"}),(0,a.kt)("h2",{id:"unidirectional-data-flow"},"Unidirectional data flow"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"view sends user initiated events to viewmodel and then viewmodel updates UI states accordingly"),(0,a.kt)("li",{parentName:"ul"},"view observes state and one-off events from viewmodel"),(0,a.kt)("li",{parentName:"ul"},"repository/use cases holds core business logic; for example when user login, this is flow of events",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"user clicks login button"),(0,a.kt)("li",{parentName:"ul"},"login button click event received in viewmodel, login method from repository called and wait for the result(set state to loading and wait until error or success is returned from repository method)"),(0,a.kt)("li",{parentName:"ul"},"repository method initiates API POST call to authenticate; The api returns success and authToken in response; repository method saves the authToken in encrypted key-value store and then return success"),(0,a.kt)("li",{parentName:"ul"},"viewmodel gets success returned from repository method; viewmodel sends one-off event of login success"),(0,a.kt)("li",{parentName:"ul"},"UI observing one-off events from viewmodel gets teh login success event and navigates to another app screen")))),(0,a.kt)("h3",{id:"compose-viewmodel-implementation"},"Compose, ViewModel implementation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'/**\n * One-off events\n */\nsealed class Effect {\n    class LoginFailed(errorMessage: String) : Effect()\n    object LoginSuccessful: Effect()\n}\n\n/**\n * State variables of screen\n */\ndata class State(\n    val userName: String = "",\n    val password: String = "",\n    val passwordVisible: Boolean = false,\n    val isLoading: Boolean = false\n)\n/**\n * User initiated actions\n */\nsealed class Action {\n    data class SetUsername(val value: String) : Action()\n    data class SetPassword(val value: String) : Action()\n    object SwitchPasswordVisibility : Action()\n    object Login : Action()\n}\n\n/**\n * Viewmodel\n */\nclass LoginViewModel(private val authUseCase: AuthUseCase): ViewModel(){\n    val state: MutableStateFlow<State>\n        field = MutableStateFlow(State())\n\n    private val effects = Channel<Effect>(UNLIMITED)\n\n    private val actionFlow = MutableSharedFlow<Action>(UNLIMITED)\n\n    init{\n        if(authUseCase.isPreviouslyLoggedIn())\n            viewModelScope.launch {\n                effects.send(Effect.LoginSuccessful)\n            }\n        actionFlow.onEach { action ->\n            when(action) {\n                is Action.SetUsername ->\n                    state.value = state.value.copy(userName =  it.value)\n                is Action.SetPassword ->\n                    state.value = state.value.copy(password =  it.value)\n                is Action.SwitchPasswordVisibility ->\n                    state.value = state.value.copy(passwordVisible = !state.value.passwordVisible)\n                is Action.Login ->\n                    login()\n            }\n        }.launchIn(viewModelScope)\n    }\n\n    fun login() =viewModelScope.launch {\n        state.value = state.value.copy(isLoading = true)\n\n        val result = authUseCase.login(LoginPayload(state.value.userName, state.value.password))\n\n        if(result is DataResult.Error)\n            effects.send(Effect.LoginFailed(getLocalizedErroMessage(result.errorCode))\n        if(result is DataResult.Success)\n            effects.send(Effect.LoginSuccessful)\n\n        state.value = state.value.copy(isLoading = false)\n    }\n\n    fun processAction(action: Action) =\n        actionFlow.tryEmit(action)\n    \n    fun effectFlow() = effects.receiveAsFlow()\n}\n\n/**\n * In navigation code\n */\n@Composable\nfun LoginDestination(){\n    val viewModel: LoginViewModel by viewModel()\n    LoginScreen(\n       loginState = viewModel.state.collectAsState().value,\n       effects = viewModel.effects.receiveAsFlow(),\n       processAction = { viewModel.processAction(it) },\n       goToForgotPasswordScreen = { navigator.navigate(MainScreenDestination) }\n   )\n}\n \n/**\n * View\n */\n@Composable\nfun LoginScreen(\n    loginState: State,\n    effects: Flow<Effect>,\n    processAction: (Action) -> Unit,\n    goToForgotPasswordScreen: () -> Unit\n){\n    ...\n    LaunchedEffect(effects) {\n        effects.onEach { effect ->\n            if (effect is Effect.LoginFailed)\n                snackBarState.showSnackBar(message = effect.errorMessage)\n            else if(effect is Effect.LoginSuccessful)\n                goToForgotPasswordScreen()\n        }.collect()\n    }\n    ...\n    Button3(\n        onClick = { processAction(Action.Login) },\n        enabled = !loginState.isLoading\n    ) {\n        if (loginState.isLoading)\n            CircularProgressIndicator()\n        else\n            Text(text = stringResource(R.string.login))\n    }\n}\n')))}v.isMDXComponent=!0},1748:function(e,n,t){var o={"./locale":9234,"./locale.js":9234};function i(e){var n=a(e);return t(n)}function a(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}i.keys=function(){return Object.keys(o)},i.resolve=a,e.exports=i,i.id=1748}}]);