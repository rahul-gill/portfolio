"use strict";(self.webpackChunkrahul_gill_github_io=self.webpackChunkrahul_gill_github_io||[]).push([[7417],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>d});var i=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,i)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,i,n=function(e,t){if(null==e)return{};var r,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)r=o[i],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)r=o[i],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=i.createContext({}),u=function(e){var t=i.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},c=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),m=u(r),d=n,h=m["".concat(s,".").concat(d)]||m[d]||p[d]||o;return r?i.createElement(h,l(l({ref:t},c),{},{components:r})):i.createElement(h,l({ref:t},c))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,l=new Array(o);l[0]=m;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a.mdxType="string"==typeof e?e:n,l[1]=a;for(var u=2;u<o;u++)l[u]=r[u];return i.createElement.apply(null,l)}return i.createElement.apply(null,r)}m.displayName="MDXCreateElement"},7728:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>u});var i=r(7462),n=(r(7294),r(3905));const o={title:"Scheduling"},l=void 0,a={unversionedId:"os/Scheduling",id:"os/Scheduling",title:"Scheduling",description:"Scheduler",source:"@site/docs/os/3. Scheduling.md",sourceDirName:"os",slug:"/os/Scheduling",permalink:"/notes/os/Scheduling",draft:!1,editUrl:"https://github.com/rahul-gill/rahul-gill.github.io/issues/new?title=Problem+on+page+deployed+at+/notes/os/Scheduling&body=%5Bfile%20to%20be%20edited%5D%28https%3A%2F%2Fgithub.com%2Frahul-gill%2Frahul-gill.github.io%2Ftree%2Fmaster%2Fdocs%2Fos/3. Scheduling.md%29",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Scheduling"},sidebar:"docs",previous:{title:"Processes and threads",permalink:"/notes/os/Processes"},next:{title:"Synchronization",permalink:"/notes/os/Synchronization"}},s={},u=[{value:"Scheduler",id:"scheduler",level:2},{value:"MLFQ",id:"mlfq",level:2}],c={toc:u};function p(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,i.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"scheduler"},"Scheduler"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"scheduling strategies",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"first come first serve, good turnaround time = completion timestamp - arrival timestamp"),(0,n.kt)("li",{parentName:"ul"},"round robin: every process gets a slice of cpu burst(io work is different) periodically, response time = first run timestamp - arrival time"),(0,n.kt)("li",{parentName:"ul"},"MLFQ(multi level feedback queue)")))),(0,n.kt)("h2",{id:"mlfq"},"MLFQ"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"many queues with different priority levels"),(0,n.kt)("li",{parentName:"ul"},"if priority of A > priority of B then only A run"),(0,n.kt)("li",{parentName:"ul"},"if priority of A = priority of B then round robin A and B"),(0,n.kt)("li",{parentName:"ul"},"when job enters the system, it has the highest process"),(0,n.kt)("li",{parentName:"ul"},"once job's cpu time reach a certain level, its priority reduced"),(0,n.kt)("li",{parentName:"ul"},"after some time, move all processes to top priority(priority boost)"),(0,n.kt)("li",{parentName:"ul"},"values with magin",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"number of queues"),(0,n.kt)("li",{parentName:"ul"},"time slice length"),(0,n.kt)("li",{parentName:"ul"},"priority boost interval"))),(0,n.kt)("li",{parentName:"ul"},"how operating systems decide the priorities",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"some have high priority for os processes where user processes can't reach"),(0,n.kt)("li",{parentName:"ul"},"some provide table for setting these value, other allow varying the values(e.g. small time slices for high priority queues)"),(0,n.kt)("li",{parentName:"ul"},"provide a way to hint the os like nice values(other similar like madvise, informed prefetch and caching)"))),(0,n.kt)("li",{parentName:"ul"},"CFS(completely fair scheduler) of linux assign proportion of cpu time instead of time slice so cpu time value depend on current load")))}p.isMDXComponent=!0}}]);