"use strict";(self.webpackChunkrahul_gill_github_io=self.webpackChunkrahul_gill_github_io||[]).push([[2174],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>d});var n=t(7294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=n.createContext({}),h=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},m=function(e){var a=h(e.components);return n.createElement(l.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=h(t),d=s,u=c["".concat(l,".").concat(d)]||c[d]||p[d]||r;return t?n.createElement(u,i(i({ref:a},m),{},{components:t})):n.createElement(u,i({ref:a},m))}));function d(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=t.length,i=new Array(r);i[0]=c;var o={};for(var l in a)hasOwnProperty.call(a,l)&&(o[l]=a[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var h=2;h<r;h++)i[h]=t[h];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},7604:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var n=t(7462),s=(t(7294),t(3905));const r={title:"Hash tables"},i=void 0,o={unversionedId:"dsa/HashTables",id:"dsa/HashTables",title:"Hash tables",description:"Hash tables are data structures for holding key-value pairs of data with $\\mathcal(1)$ amortized add, delete and find operation. But the order information of keys is lost unlike the balanced tree structures.",source:"@site/docs/dsa/HashTables.md",sourceDirName:"dsa",slug:"/dsa/HashTables",permalink:"/notes/dsa/HashTables",draft:!1,editUrl:"https://github.com/rahul-gill/rahul-gill.github.io/issues/new?title=Problem+on+page+deployed+at+/notes/dsa/HashTables&body=%5Bfile%20to%20be%20edited%5D%28https%3A%2F%2Fgithub.com%2Frahul-gill%2Frahul-gill.github.io%2Ftree%2Fmaster%2Fdocs%2Fdsa/HashTables.md%29",tags:[],version:"current",frontMatter:{title:"Hash tables"},sidebar:"docs",previous:{title:"Order Statistics",permalink:"/notes/dsa/OrderStatistics"},next:{title:"Heaps",permalink:"/notes/dsa/Heaps"}},l={},h=[{value:"Technieques For Handling Collisions",id:"technieques-for-handling-collisions",level:2},{value:"Open addressing",id:"open-addressing",level:3},{value:"Chaining",id:"chaining",level:2}],m={toc:h};function p(e){let{components:a,...t}=e;return(0,s.kt)("wrapper",(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Hash tables are data structures for holding key-value pairs of data with ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(1)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," amortized add, delete and find operation. But the order information of keys is lost unlike the balanced tree structures."),(0,s.kt)("p",null,"When the keys are simple and the space of keys is small, a simple mapping from keys to array indexes is suffice.\nFor example for key-value mapping of student roll numbers and their results. We'll just use ",(0,s.kt)("inlineCode",{parentName:"p"},"roll_no-1")," as index for the array in which we store the results. We can access the result of a student in ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(1)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," with accessing ",(0,s.kt)("inlineCode",{parentName:"p"},"arr[roll_no-1]"),". For deleting, we can put a flag as value for the key, we can put null, -1 or something like that."),(0,s.kt)("p",null,"When the space of keys is large, for example when keys can have values ranging from 1 to 1e6, we'll need a way to map the keys to array indexes. For that we use hash functions. Although, we can simply do modulo operation by the size of array on the keys to map them to index, but that could result in lots of keys getting the same index, we'll see how hash functions and some techniques help with that."),(0,s.kt)("p",null,"A hash function returns an interger value, should take just a few cpu cycles for computation and must return the same value for same object. But a hash function can return same value for two object, we call it a collision.\nNow how do we make use of hash functions to compute indexes to store the object in hash table array? A hash function can also have large values just like original keys, but hash function return values are randomly distributed and are less like to cause collisions. We can't completely elimiate collision so we'll use some techniques to help with that."),(0,s.kt)("p",null,"A sample hash function for string is given below(java language use this hash function for strings, ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/openjdk/jdk/blob/ed23033dc6b3d4833ce2c8d07f273747ab8ae406/src/java.base/share/classes/java/lang/StringUTF16.java#L414"},"see here"),")"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"int hashCode(string value) {\n    int h = 0;\n    for(char x: value)\n        h = 31 * h + x;\n    return h;\n}\n")),(0,s.kt)("p",null,"Here, to account for the position of characters in string, we multiply then by ",(0,s.kt)("inlineCode",{parentName:"p"},"const^char_position")," the choosen const here is 31.\nTo convert the hash to table index, we use modulo operation(",(0,s.kt)("inlineCode",{parentName:"p"},"hash % table_size"),", to optimize this approach we choose only prime numbers sizes of table(approach used by c++,",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gcc-mirror/gcc/blob/5bea0e90e58d971cf3e67f784a116d81a20b927a/libstdc%2B%2B-v3/src/shared/hashtable-aux.cc#L28"},"see here"),")\nwe also make the hash value positive by resetting the sign bit of signed integer. In 2's complement notation, the most signification bit is the sign bit. To reset sign bit we take bitwise and of the number and ",(0,s.kt)("inlineCode",{parentName:"p"},"0x7F"),"(for 8 bit hash function)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"0b0000\xa00000 -> 0\n0b0000 0001 -> 1\n0b1000 0000 -> -128\n0b1111 1111 -> -1 \n\n0b1000 0000 & 0b0111 1111 = 0b0000\xa00000 -> 0\n0b1111 1111 & 0b0111 1111 = 0b0111 1111 -> 127\n")),(0,s.kt)("p",null,"So the overall index is"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t compute_index(string obj, size_t table_size){\n    int hash = hashCode(obj);\n    hash &= 0x7FFFFFFF;//this constant depend on character size\n    hash %= table_size;\n    return hash;\n}\n")),(0,s.kt)("p",null,"load factor ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03b1"),(0,s.kt)("mo",{parentName:"mrow"},"=")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\alpha =")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"=")))))," number of entries / total size of array\nlarger load factor indicates, that we might need to increase size of the table array and rehash the entries."),(0,s.kt)("h2",{id:"technieques-for-handling-collisions"},"Technieques For Handling Collisions"),(0,s.kt)("h3",{id:"open-addressing"},"Open addressing"),(0,s.kt)("p",null,"when we face a collision, during insertion lets say at index ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"k")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k"))))),",  and if there's not a value there, we put the extra entry there.\nNow when finding a key, we have to compare the key to find and the key at the computed index and if they do not match, we look at indexes that come after that indexes in same as we did during the insertion. When the compared keys are identical, we return that entry.\nWhen deleting an entry which is not at the computed index and rather at a later index, we put a flag at that entry, so that when we search again, we indicate to keep looking further.\nIts importent to use the same formula to choose the next index in these operation.\nThere are multiple techniques for choosing which indexes to look at."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"linear probing hash_idx -> hash_idx + 1 -> hash_idx + 2"),(0,s.kt)("li",{parentName:"ul"},"quadratic probling: hash_idx -> hash_idx ",(0,s.kt)("em",{parentName:"li"}," 2 -> hash_idx ")," 4"),(0,s.kt)("li",{parentName:"ul"},"double hashing:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"two different hash functions, second hash function must not return 0"),(0,s.kt)("li",{parentName:"ul"},"in case of collision: hash_idx -> hash_idx + second_hash_val -> hash_idx + second_hash_val*2"))),(0,s.kt)("li",{parentName:"ul"},"in open addressing , we have to consider resizing the table array once load factor is about 0.6-0.7(resizing and rehashing is amortized O(1))")),(0,s.kt)("h2",{id:"chaining"},"Chaining"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"most used"),(0,s.kt)("li",{parentName:"ul"},"chaining: array of linked lists, instead of simple array, for computed hash index ",(0,s.kt)("inlineCode",{parentName:"li"},"hash_idx")," we store the entry in the linked list at index ",(0,s.kt)("inlineCode",{parentName:"li"},"hash_idx")),(0,s.kt)("li",{parentName:"ul"},"using chaining, we can have larger load factor. we can consider rehashing when the load factor is about one."),(0,s.kt)("li",{parentName:"ul"},"for rehashing, we'll have to create new array of linked list and then copy the entries while using the new table size for modulo operation during calculation of hash index")))}p.isMDXComponent=!0}}]);